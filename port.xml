<?xml version="1.0" encoding="UTF8"?>
<Export generator="Cache" version="25">
<Class name="Port.AutoInstall">
<Super>%Projection.AbstractProjection</Super>
<TimeCreated>64463,49658.530976</TimeCreated>

<Projection name="Reference">
<Type>Port.AutoInstall</Type>
</Projection>

<Method name="CreateProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit ##class(Installer).Install()
]]></Implementation>
</Method>

<Method name="RemoveProjection">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[classname:%String,&parameters:%String,recompile:%Boolean,modified:%String,qstruct]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  quit ##class(Installer).Uninstall()
]]></Implementation>
</Method>
</Class>


<Class name="Port.Configuration">
<IncludeCode>portutils</IncludeCode>
<Super>%SYSTEM.Help</Super>
<TimeCreated>64306,34528.990495</TimeCreated>

<Method name="SetLogLevel">
<Description>
Sets the log level verbosity used to display the info. Ranging from 1 to 2, greater provides more detailed info.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>logLevel:%Integer</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if logLevel > 0 && (logLevel < 3) {
    set ^Port.Configuration("general.logLevel") = logLevel
    return $$$OK
  }
  return $$$PERROR($$$LogLevelIsOutOfRange, "1, 2")
]]></Implementation>
</Method>

<Method name="GetLogLevel">
<Description>
Gets the current configured log level.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $get(^Port.Configuration("general.logLevel"), 0)
]]></Implementation>
</Method>

<Method name="SetPrimaryWorkspace">
<Description>
Sets the primary path where the project should be exported. This can be overwritten by SetCustomWorkspace.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newWorkspace:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  set ^Port.Configuration("source.path") = $select(newWorkspace = "" : "/CacheProjects/{NAMESPACE}/{PROJECT}", 1: newWorkspace)
]]></Implementation>
</Method>

<Method name="GetWorkspace">
<Description>
Resolves any placeholders and gets the precise path for the specified project. This priorizes the custom workspace and falls back to the primary.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String=$get(^||Port.Project)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set customWorkspace = ..GetCustomWorkspace(projectName)
  if customWorkspace '= "" return ..RewritePlaceHolders(customWorkspace, projectName,$lb("{NAMESPACE}","{PROJECT}","{USERNAME}"))
  return ..RewritePlaceHolders($get(^Port.Configuration("source.path")), projectName, $lb("{NAMESPACE}","{INSTALLDIR}","{PROJECT}","{USERNAME}"))
]]></Implementation>
</Method>

<Method name="EnableAutoExportXML">
<Description>
Generates and export a XML project whenever a item is saved. This is useful for keeping the project XML always up-to-date.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  set ^Port.Configuration("xml.autoexport") = 1
]]></Implementation>
</Method>

<Method name="DisableAutoExportXML">
<Description>
Disables the generation of the project XML file.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  set ^Port.Configuration("xml.autoexport") = 0
]]></Implementation>
</Method>

<Method name="IsAutoExportXMLEnabled">
<Description>
Returns if project XML generation is enabled.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ($get(^Port.Configuration("xml.autoexport")) = 1)
]]></Implementation>
</Method>

<Method name="SetTestPath">
<Description>
Relative to it's project. Sets the path where test cases should be exported.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newPath:%String=""</FormalSpec>
<Implementation><![CDATA[
  
  set ^Port.Configuration("test.path") = $select(newPath = "" : "tests/cls", 1: newPath)
]]></Implementation>
</Method>

<Method name="GetTestPath">
<Description>
Retrives the resolved path where tests are being exported.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return ..RewritePlaceHolders($get(^Port.Configuration("test.path")),,$lb("{NAMESPACE}","{PROJECT}","{USERNAME}"))
]]></Implementation>
</Method>

<Method name="EnableTestOnDemand">
<Description>
Allows Port to run matching test cases whenever the match is compiled.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.Configuration("test.ondemand") = 1
]]></Implementation>
</Method>

<Method name="DisableTestOnDemand">
<Description>
Prevents Port from running test cases automatically.</Description>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[  set ^Port.Configuration("test.ondemand") = 0
]]></Implementation>
</Method>

<Method name="IsTestOnDemandEnabled">
<Description>
Retrieves if Port is configured to run test cases automatically.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return ($get(^Port.Configuration("test.ondemand")) = 1)
]]></Implementation>
</Method>

<Method name="SetTestClassPrefix">
<Description>
Sets the prefix used to match against the implementation classe.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>newPrefix:%String=""</FormalSpec>
<Implementation><![CDATA[  set ^Port.Configuration("test.prefix") = $select(newPrefix = "" : "UnitTest", 1: newPrefix)
]]></Implementation>
</Method>

<Method name="GetTestClassPrefix">
<Description>
Gets the associated test prefix.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  return $get(^Port.Configuration("test.prefix"))
]]></Implementation>
</Method>

<Method name="SetSourceExtension">
<Description>
Defines the extension to be appended when exporting Cach√© files. If extension starts with a dot, it will be removed.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>value:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..TrackActiveExtension()
  if $extract(value) = "." set value = $extract(value, 2, *)
  set ^Port.Configuration("source.extension") = value
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetSourceExtension">
<Description>
Gets the appending source extension.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  set extension = $get(^Port.Configuration("source.extension"))
  if extension = "" return extension
  return extension
]]></Implementation>
</Method>

<Method name="IsSameSourceExtension">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  // For internal use only: Checks if the configured extension is the same than the last one
  // used to export a project. If it isn't, an exception will be fired.
  set extension = ..GetSourceExtension()
  return (extension = $get(^Port.Configuration("internals.trackers.extension")))
]]></Implementation>
</Method>

<Method name="SetCustomWorkspace">
<Description>
Defines a custom workspace, a path where a single project should be exported. This configuration ovewrites the primary workspace.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,path:%String=..GetWorkspace()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ^Port.Configuration("workspace.project", projectName) = path
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetCustomWorkspace">
<Description>
Retrieves the resolved workspace path for the provided project. Returns empty if there's none.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set customWorkspace = $get(^Port.Configuration("workspace.project", projectName))
  return ..RewritePlaceHolders(customWorkspace, projectName, $lb("{NAMESPACE}","{INSTALLDIR}","{PROJECT}","{USERNAME}"))
]]></Implementation>
</Method>

<Method name="HasCustomWorkspace">
<Description>
Returns if the project has a custom workspace.</Description>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 
  return (..GetCustomWorkspace(projectName) '= "")
]]></Implementation>
</Method>

<Method name="RemoveCustomWorkspace">
<Description>
Removes the custom workspace from the project provided, which also resets it back to using the primary.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String</FormalSpec>
<Implementation><![CDATA[  kill ^Port.Configuration("workspace.project", projectName)
]]></Implementation>
</Method>

<Method name="Uninstall">
<Description>
Remove all Port configurations. This will not erase project logs.</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill ^Port.Configuration
  return $$$OK
]]></Implementation>
</Method>

<Method name="RegisterExtendedHooks">
<Description>
Defines a class used to handle source control hooks after Port execution.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>implementer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if implementer = "" kill ^Port.Configuration("source.hooks.custom")
  if '##class(%Dictionary.CompiledClass).%ExistsId(implementer) return $$$ERROR($$$ClassDoesNotExist, implementer)
  set ^Port.Configuration("source.hooks.custom") = implementer
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetExtendedHooksImplementer">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $get(^Port.Configuration("source.hooks.custom"))
]]></Implementation>
</Method>

<Method name="RewritePlaceHolders">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>basePath:%String,projectName:%String=$get(^||Port.Project),allowedPlaceholders="*",params...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 
  if '$data(params) set params = ""
  set translatedPath = basePath  
  #define RewriteIfPathContains(%expression, %replacement) if ($lv(allowedPlaceholders) && $lf(allowedPlaceholders, %expression)) || (allowedPlaceholders = "*") set translatedPath = $select(translatedPath [ %expression : $replace(translatedPath, %expression, %replacement), 1: translatedPath) 
  
  set installDirectory = $System.Util.InstallDirectory()
  set installDirectory = $extract(installDirectory, 1, $length(installDirectory) - 1)
  $$$RewriteIfPathContains("{NAMESPACE}", $namespace)
  $$$RewriteIfPathContains("{INSTALLDIR}", installDirectory)
  $$$RewriteIfPathContains("{USERNAME}", $username) 
  $$$RewriteIfPathContains("{EXPORTPATH}", ..GetWorkspace())
  $$$RewriteIfPathContains("{FULLEXPORTPATH}", ##class(%File).NormalizeFilename(..GetWorkspace())) 
  $$$RewriteIfPathContains("{SLASH}", $select($$$isWINDOWS: "\", 1: "/"))
  $$$RewriteIfPathContains("{PROJECT}", projectName) 
  
  if params {
    for i=1:1:params $$$RewriteIfPathContains("{P"_i_"}", params(i))
  }
  return translatedPath
]]></Implementation>
</Method>

<Method name="TrackActiveExtension">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  // For internal use only: Updates the last used extension to match the current configuration.
  set ^Port.Configuration("internals.trackers.extension") = ..GetSourceExtension()
]]></Implementation>
</Method>

<Method name="GetWebAppPath">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  // For internal use only: Performs a quick search of the web app path that is registered when Port is installed.
  return $get(^Port.Configuration("internals.webapp.path"))
]]></Implementation>
</Method>
</Class>


<Class name="Port.Installer">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64306,34529.365286</TimeCreated>

<XData name="LocaleEN">
<XMLNamespace>https://github.com/rfns/port</XMLNamespace>
<Data><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<MsgFile Language="en">
  <MsgDomain Domain="Port Errors">
    <Message Id="-100" Name="InvalidPhysicalPath">The provided physical path '%1' is not part of the static files directory.</Message>
    <Message Id="-101" Name="NamespaceDoesntHaveAppWithPath">There is not an application with a physical path for the namespace %1.</Message>
    <Message Id="-102" Name="CannotCreateDirectory">Could not create the directory %1.</Message>
    <Message Id="-103" Name="CannotUseRelativePath">Cannot use a relative path, an absolute path must be provided.</Message>
    <Message Id="-104" Name="UnableToCopySource">Could not copy the file from %1 to %2.</Message> 
    <Message Id="-105" Name="UnableToExportInvalidItem">Could not export the item %1 because it does not exist.</Message>
    <Message Id="-106" Name="ErrorsWhileImporting">There were errors while export the project %1.</Message>
    <Message Id="-107" Name="AmbiguousPartialToWorkspace">The obtained partial path %1 is ambiguous to this project path. If you want to export the project itself, then use the 'Import' method.</Message>
    <Message Id="-108" Name="SupressedAttemptToExportFromOutside">Cannot import a file that is outside the project workspace.</Message>    
    <Message Id="-109" Name="UnableToRemoveDirectory">Could not remove the directory %1.</Message>
    <Message Id="-110" Name="UnableToDescribeItem">Could not describe the item %1 due to a violation regarding the expected extension: this item should %2</Message>
    <Message Id="-111" Name="PortIsNotInstalled">Port is not installed on namespace %1.</Message>
    <Message Id="-112" Name="NoTestSuitesWereFound">No tests suites were found for this project.</Message>
    <Message Id="-113" Name="ExportingProjectNotFound">The selected %1 project does not exist.</Message>
    <Message Id="-114" Name="ErrorsWhileImportingType">There were errors while importing items type of %1.</Message>
    <Message Id="-115" Name="LogLevelIsOutOfRange">The provided log level %1 is out of range. Parameter must be one of: %2.</Message>
    <Message Id="-116" Name="CouldNotDetermineWorkspace">Could not determine the correct workspace from the provided path.</Message>
    <Message Id="-117" Name="CannotSaveConflictingItems">Cannot save items that belongs to other projects. Please remove '%1' from the projects listed below if you want to save it into '%3': %2</Message>
    <Message Id="-118" Name="FailedWhileRunningExtendedHook">Failed while running extended hook '%1'.</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Log Messages">
    <Message Id="-200" Name="BackupStart">Starting backup ...</Message>
    <Message Id="-201" Name="BackupAlert">DO NOT INTERRUPT THIS PROCESS.</Message>
    <Message Id="-202" Name="BackupMirror">Mirroring the web application to a temporary directory ...</Message>
    <Message Id="-203" Name="RemovingBackupMirror">Removing the temporary directory.</Message>
    <Message Id="-300" Name="NoItemsToExport">There are no items to export. The operation has been aborted.</Message>
    <Message Id="-301" Name="ExportingProject">Exporting the project %1.</Message>
    <Message Id="-302" Name="SourceExportedToPath">The source code has been exported to the path %1.</Message>
    <Message Id="-303" Name="ExportingType">Exporting %1 %2 ...</Message>
    <Message Id="-304" Name="NewWorkspaceDetected">A new workspace has been detected for %1. The project will be exported as a whole.</Message>
    <Message Id="-400" Name="SynchronizingProject">Synchronizing the project %1.</Message>
    <Message Id="-401" Name="CheckingExtraneousItems">Checking for the presence of orphan items in the project.</Message>
    <Message Id="-402" Name="TotalExtraneousItems">Total orphan items detected: %1.</Message>
    <Message Id="-403" Name="NoExtraneousItems">No orphan items were found.</Message>
    <Message Id="-404" Name="RemovingFile">Removing %1 (file).</Message>
    <Message Id="-405" Name="RemovingDirectory">Removing item %1 (directory).</Message>
    <Message Id="-406" Name="TotalExtraneousItemsRemoved">Total of removed orphan items: %1</Message>
    <Message Id="-500" Name="Done"> done.</Message>
    <Message Id="-501" Name="DoneWithErrors"> done, but with errors.</Message>
    <Message Id="-501" Name="Failed"> failed.</Message>
    <Message Id="-502" Name="AllDone">Finished with success.</Message>
    <Message Id="-503" Name="KeepCacheExtension"> keep your original format.</Message>
    <Message Id="-504" Name="OvewriteWithExtension"> end with the %1 extension.</Message>
    <Message Id="-600" Name="ImportingType">Importing %1 %2 ...</Message>
    <Message Id="-601" Name="EnqueingType">Enqueueing the selected %1 to be imported.</Message>
    <Message Id="-602" Name="NothingToImport">Nothing to import has been found.</Message>
    <Message Id="-603" Name="ImportingProject">Importing the project %1.</Message>
    <Message Id="-604" Name="EnqueueingItems">Enqueing items to be imported ...</Message>
    <Message Id="-605" Name="TotalItemsToImport">Total of items to import: %1.</Message>
    <Message Id="-606" Name="NoPendingItemsToImport">No items to import were found.</Message>
    <Message Id="-607" Name="NewProject">The project %1 does not exist yet and will be created.</Message>
    <Message Id="-608" Name="FatalErrorAlert">FATAL: The following errors prevented the project from being imported:</Message>
    <Message Id="-609" Name="FatalRollbackAlert">All changes will be discarded on the next steps.</Message>
    <Message Id="-610" Name="FatalProjectIntegrityRiskWarning">WARNING! DO NOT INTERRUPT THE PROCESS TO AVOID COMPROMISING THE PROJECT INTEGRITY!</Message>
    <Message Id="-611" Name="FatalRollingBackTransaction">Discarding the pending transaction ...</Message>
    <Message Id="-612" Name="FatalApplyingBackup">Applying the backup to revert the web application back to its initial state.</Message>
    <Message Id="-613" Name="FatalFailedToRestoreBackup">ERROR: Could not apply the backup entirely due to a system error. The backup will be kept to be applied manually.</Message>    
    <Message Id="-614" Name="ProjectSaved">The project %1 has been saved with %2 items.</Message>
    <Message Id="-700" Name="CannotUseDefault">The usage of 'Default' named projects is prohibited. If you want use this project, you must provide another name by using File->Save As.</Message>
    <Message Id="-701" Name="CannotUseDefault2">All active hooks are now disabled.</Message>    
    <Message Id="-800" Name="ClassType">class</Message>
    <Message Id="-801" Name="ProjectType">project</Message>
    <Message Id="-802" Name="RoutineType">routine</Message>
    <Message Id="-803" Name="FileType">file</Message>
    <Message Id="-804" Name="DirectoryType">diret√≥rio</Message>
    <Message Id="-805" Name="MACGroupType">macro routines</Message>
    <Message Id="-806" Name="INCGroupType">include files</Message>
    <Message Id="-807" Name="INTGroupType">intermediate routines</Message>
    <Message Id="-808" Name="BASGroupType">Basic routines</Message>
    <Message Id="-809" Name="MVBGroupType">MV Basic routines</Message>
    <Message Id="-810" Name="MVIGroupType">MVI routines</Message>
    <Message Id="-811" Name="DFIGroupType">DFI files</Message>
    <Message Id="-812" Name="CLSGroupType">classes</Message>
    <Message Id="-813" Name="FileGroupType">files</Message>
    <Message Id="-900" Name="ExportingXML">Exporting the project %1 to XML ...</Message>
    <Message Id="-901" Name="XMLExportedTo">%1 project XML exported to %2.</Message>
    <Message Id="-902" Name="ExportingTestClassToXML">Exporting test class %1 ...</Message>
    <Message Id="-1000" Name="ConflictingItemDetected">CAUTION! Detected the usage of the item %1 on the following projects: %2.</Message>
    <Message Id="-1001" Name="ConflictingItemDetected2">It's extremely recommended to keep the item exclusive to a single project!</Message>
    <Message Id="-1100" Name="RunningCustomHook">Executing hook extension %1 from the class %2 ...</Message>
    <Message Id="-1101" Name="HookReturnedOK">%1 returned without errors.</Message>
    <Message Id="-1102" Name="HookReturnedError">Failed while executing %1 due to the following reason: %2.</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Menu Labels">
    <Message Id="-5000" Name="MLExport">Export</Message>    
    <Message Id="-5001" Name="MLExportToXML">Export to XML</Message>
    <Message Id="-5002" Name="MLExportTests">Export tests</Message>
    <Message Id="-5003" Name="MLRemoveClasses">Remove classes</Message>
    <Message Id="-5004" Name="MLRemoveFiles">Remove files</Message>
    <Message Id="-5005" Name="MLRemoveRoutines">Remove routines</Message>
    <Message Id="-5006" Name="MLScanAndFix">Scan and fix</Message>
    <Message Id="-5007" Name="MLRunTests">Run tests</Message>
    <Message Id="-5008" Name="MLImport">Import</Message>
    <Message Id="-5009" Name="MLForceExport">Export (forced)</Message>
    <Message Id="-5010" Name="MLForceImport">Import (forced)</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Context Menu Labels">
    <Message Id="-6000" Name="CMLExportActive">Export from here</Message>
    <Message Id="-6001" Name="CMLImportActive">Import from here</Message>
    <Message Id="-6002" Name="CMLRunActiveTest">Run test</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Configuration Wizard">
    <Message Id="-7000" Name="PCWWelcome">Welcome to the Port configuration wizard.</Message>
    <Message Id="-7001" Name="PCWInvalidChoice">Invalid choice.</Message>
    <Message Id="-7002" Name="PCWChoiceQuestion">What do you want to do? (type the number)</Message>
    <Message Id="-7003" Name="PCWChoicePrompt">Your choice: </Message>
    <Message Id="-7004" Name="PCWAborted">Aborted.</Message>
    <Message Id="-7005" Name="PCWToggleEnabled">ENABLED</Message>
    <Message Id="-7006" Name="PCWToggleDisabled">DISABLED</Message>
    <Message Id="-7007" Name="PCWBye">Bye.</Message>
    <Message Id="-7100" Name="PCWManageWorkspaceChoice">1. Manage workspaces.</Message>
    <Message Id="-7101" Name="PCWManageWorkspaceDescription">Manages workspaces that will contain the exported source code.</Message>
    <Message Id="-7110" Name="PCWManageWorkspaceChoice1">1. Change primary workspace.</Message>
    <Message Id="-7111" Name="PCWManageWorkspaceChoice1Description">Configures the primary workspace that will be used to export your source code.</Message>    
    <Message Id="-7112" Name="PCWManageWorkspaceChoice1StatusCurrent">The current primary workspace is %1.</Message>
    <Message Id="-7113" Name="PCWManageWorkspaceChoice1StatusNow">The primary workspace is now set to %1.</Message>    
    <Message Id="-7120" Name="PCWManageWorkspaceChoice2">2. Manage existing workspaces.</Message>
    <Message Id="-7121" Name="PCWManageWorkspaceChoice2Description">Manages workspaces associated to projects.</Message>
    <Message Id="-7122" Name="PCWManageWorkspaceChoice2Description2">Projects named here will not use the primary workspace definition.</Message>
    <Message Id="-7123" Name="PCWManageWorkspaceChoice2Prompt">Type the name of the project (or leave it empty to abort):</Message>
    <Message Id="-7124" Name="PCWManageWorkspaceChoice2Warning">WARNING: The project %1 doesn't exist yet."</Message>
    <Message Id="-7125" Name="PCWManageWorkspaceChoice2StatusCurrent">Current workspace for this project is: %1.</Message>
    <Message Id="-7126" Name="PCWManageWorkspaceChoice2CurrentWorskpaceWarn">You will be asked for a new workspace now.</Message>
    <Message Id="-7127" Name="PCWManageWorkspaceChoice2Prompt2">Type the workspace path (or leave it empty to abort):</Message>
    <Message Id="-7128" Name="PCWManageWorkspaceChoice2StatusNow">The project %1 is now configured to be exported using the following path: %2.</Message>
    <Message Id="-7200" Name="PCWManageChangeTestSettingsChoice">2. Change test settings.</Message>
    <Message Id="-7201" Name="PCWManageChangeTestSettingsDescription">Configures settings related to the Studio test integration.</Message>
    <Message Id="-7210" Name="PCWManageChangeTestSettingsChoice1">1. Enable or disable test on demand.</Message>
    <Message Id="-7211" Name="PCWManageChangeTestSettingsChoice1Description">When this settings is enabled, Port will try to match the test class prefix and run the related test.</Message>
    <Message Id="-7212" Name="PCWManageChangeTestSettingsChoice1Choice1">1. Enable test on demand.</Message>
    <Message Id="-7213" Name="PCWManageChangeTestSettingsChoice1Choice2">2. Disable test on demand.</Message>
    <Message Id="-7214" Name="PCWManageChangeTestSettingsChoice1StatusCurrent">Test on demand is currently %1.</Message>
    <Message Id="-7220" Name="PCWManageChangeTestSettingsChoice2">2. Define a new test class prefix.</Message>
    <Message Id="-7221" Name="PCWManageChangeTestSettingsChoice2Description">A test class prefix is required to inform Port which package should be considered as a test package.</Message>
    <Message Id="-7222" Name="PCWManageChangeTestSettingsChoice2Description2">Port uses this prefix when trying to find an equivalent implementation class.</Message>
    <Message Id="-7223" Name="PCWManageChangeTestSettingsChoice2Description3">Ex: UnitTest.MyPackage.MyClass -> MyPackage.MyClass.</Message>
    <Message Id="-7224" Name="PCWManageChangeTestSettingsChoice2Prompt">Please type the prefix below. Note that prefixes can also be composed. Ex: Package.UnitTest.</Message>
    <Message Id="-7225" Name="PCWManageChangeTestSettingsChoice2StatusNow">The prefix is now set to: %1.</Message>
    <Message Id="-7230" Name="PCWManageChangeTestSettingsChoice3">3. Define the path where unit test classes should exported (XML).</Message>
    <Message Id="-7231" Name="PCWManageChangeTestSettingsChoice3Description">Defines the path where the each test classes should be exported.</Message>
    <Message Id="-7232" Name="PCWManageChangeTestSettingsChoice3StatusNow">"The test path is now set to: %1.</Message>
    <Message Id="-7300" Name="PCWToggleAutoExportChoice">3. Toggle project XML auto-export.</Message>
    <Message Id="-7301" Name="PCWToggleAutoExportDescription">Exports a XML file from project when a document is saved.</Message>
    <Message Id="-7302" Name="PCWToggleAutoExportChoice1StatusCurrent">Auto-export XML is currently %1.</Message>
    <Message Id="-7303" Name="PCWToggleAutoExportChoice1StatusNow">Auto-export XML is now %1.</Message>
    <Message Id="-7310" Name="PCWToggleAutoExportChoice1">1. Enable project XML auto-export.</Message>
    <Message Id="-7320" Name="PCWToggleAutoExportChoice2">2. Disable project XML auto-export.</Message>    
    <Message Id="-7400" Name="PCWSetLogLevelChoice">4. Set log level.</Message>
    <Message Id="-7401" Name="PCWSetLogLevelDescription">Specifies the log verbosity level when displaying operations.</Message>
    <Message Id="-7402" Name="PCWSetLogLevelStatusCurrent">Log verbosity level is currently: %1.</Message>
    <Message Id="-7403" Name="PCWSetLogLevelStatusNow">Log verbosity level is now: %1.</Message>
    <Message Id="-7404" Name="PCWSetLogLevelStatusPrompt">Please set the log verbosity level (type the number): </Message>
    <Message Id="-7410" Name="PCWSetLogLevelStatusChoice1">1. Level 1: Displays item enqueieing, import categories, backup notifications, repository status and error messages.</Message>
    <Message Id="-7420" Name="PCWSetLogLevelStatusChoice2">2. Level 2: Includes all verbosity from Level 1 plus detailed logging about atomical operations.</Message>
    <Message Id="-7500" Name="PCWSetSourceExtensionChoice">5. Set source extension.</Message>
    <Message Id="-7501" Name="PCWSetSourceExtensionDescription">Defines an extension to be appended globaly to every exported routine.</Message>    
    <Message Id="-7502" Name="PWCSetSourceExtensionPrompt">Please type the extension below</Message>
    <Message Id="-7503" Name="PWCSetSourceExtensionStatusNow">The extension is now set to: %1</Message>
    <Message Id="-7600" Name="PCWExit">6. Exit.</Message>
    <Message Id="-7970" Name="PCWPlaceholdersAnnounce">You can use the following specific placeholders:</Message>
    <Message Id="-7971" Name="PCWPlaceholdersProject">{PROJECT} - The active project name.</Message>
    <Message Id="-7972" Name="PCWPlaceholdersNamespace">{NAMESPACE} - The active namespace name.</Message>
    <Message Id="-7973" Name="PCWPlaceholdersUsername">{USERNAME} - The active user name.</Message>
    <Message Id="-7974" Name="PCWPlaceholdersInstallDir">{INSTALLDIR} - The Cach√© installation directory.</Message>
    <Message Id="-7980" Name="PCWPathRelative">Please type the RELATIVE path to be used when exporting your test files. Paths should be relative to the exported project root. (Or leave it empty to restore the default)</Message>
    <Message Id="-7981" Name="PCWPathAbsolute">Please type the ABSOLUTE path to be used when exporting your source files (Or leave it empty to restore the default)</Message>
    <Message Id="-7982" Name="PCWPathOSSchemes">You can use both: *NIX or Windows schemes.</Message>
    <Message Id="-7983" Name="PCWPathDefault">Default is:</Message>
    <Message Id="-7984" Name="PCWPathCurrent">Current is:</Message>
    <Message Id="-7985" Name="PCWPathNew">New: </Message>
    <Message Id="-7999" Name="PCWGoBackChoice">%1. Go back.</Message>
  </MsgDomain>
</MsgFile>
]]></Data>
</XData>

<XData name="LocalePTBR">
<XMLNamespace>https://github.com/rnfs/port</XMLNamespace>
<Data><![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
<MsgFile Language="pt-br">
  <MsgDomain Domain="Port Errors">
    <Message Id="-100" Name="InvalidPhysicalPath">O caminho f√≠sico '%1' fornecido n√£o pertence ao diret√≥rio de arquivos est√°ticos.</Message>
    <Message Id="-101" Name="NamespaceDoesntHaveAppWithPath">N√£o existe uma aplica√ß√£o com caminho f√≠sico para o namespace %1.</Message>
    <Message Id="-102" Name="CannotCreateDirectory">N√£o foi poss√≠vel criar o diret√≥rio %1.</Message>
    <Message Id="-103" Name="CannotUseRelativePath">N√£o √© poss√≠vel utilizar um caminho relativo, o caminho precisa estar completo.</Message> 
    <Message Id="-104" Name="UnableToCopySource">N√£o foi poss√≠vel copiar o arquivo de %1 para %2.</Message> 
    <Message Id="-105" Name="UnableToExportInvalidItem">N√£o foi poss√≠vel exportar o item %1 pois ele n√£o existe.</Message>
    <Message Id="-106" Name="ErrorsWhileImporting">Houveram erros ao importar %1.</Message>
    <Message Id="-107" Name="AmbiguousPartialToWorkspace">O caminho partial %1 obtido √© amb√≠guo ao caminho deste projeto. Se voc√™ deseja exportar o projeto, utilize o m√©todo 'Import'.</Message>
    <Message Id="-108" Name="SupressedAttemptToExportFromOutside">N√£o √© poss√≠vel importar um arquivo que esteja fora do espa√ßo de trabalho deste projeto.</Message>
    <Message Id="-109" Name="UnableToRemoveDirectory">N√£o foi poss√≠vel remover o diret√≥rio %1.</Message>
    <Message Id="-110" Name="UnableToDescribeItem">N√£o foi poss√≠vel descrever o item o %1 devido √† uma viola√ß√£o no extens√£o esperada: este item deve %2</Message>
    <Message Id="-111" Name="PortIsNotInstalled">Port n√£o est√° instalado no namespace %1.</Message>
    <Message Id="-112" Name="NoTestSuitesWereFound">N√£o foram encontradas su√≠tes de teste para este projeto.</Message>
    <Message Id="-113" Name="ExportingProjectNotFound">O projeto %1 selecionado para ser exportado n√£o existe.</Message>
    <Message Id="-114" Name="ErrorsWhileImportingType">Houveram errors ao importar itens do tipo %1.</Message>
    <Message Id="-115" Name="LogLevelIsOutOfRange">O n√≠vel de log fornecido est√° fora da faixa permitida. O par√¢metro deve ser um destes: %2.</Message>
    <Message Id="-116" Name="CouldNotDetermineWorkspace">N√£o foi poss√≠vel determinar o espa√ßo de trabalho correto a patir do caminho fornecido.</Message>
    <Message Id="-117" Name="CannotSaveConflictingItems">N√£o √© poss√≠vel salvar itens que perten√ßam a outros projetos. Por favor remova o item %1 dos projetos abaixo se voc√™ deseja salv√°-lo em '%3': %2</Message>
    <Message Id="-118" Name="FailedWhileRunningExtendedHook">Falha ao rodar extens√£o do evento '%1'.</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Log Messages">
    <Message Id="-200" Name="BackupStart">Iniciando backup...</Message>
    <Message Id="-201" Name="BackupAlert">N√ÉO INTERROMPA ESTE PROCESSO.</Message>
    <Message Id="-202" Name="BackupMirror">Espelhando a estrutura da aplica√ß√£o web para um diret√≥rio tempor√°rio ... </Message>
    <Message Id="-203" Name="RemovingBackupMirror">Removendo o diret√≥rio tempor√°rio.</Message>
    <Message Id="-300" Name="NoItemsToExport">N√£o h√° itens para serem exportados. A opera√ß√£o foi abortada.</Message>
    <Message Id="-301" Name="ExportingProject">Exportando o projeto %1.</Message>
    <Message Id="-302" Name="SourceExportedToPath">O c√≥digo-fonte foi exportado para o caminho %1.</Message>
    <Message Id="-303" Name="ExportingType">Exportando %1 %2 ...</Message>
    <Message Id="-304" Name="NewWorkspaceDetected">Um novo espa√ßo de trabalho foi detectado para %1. O projeto ser√° exportado como um todo.</Message>
    <Message Id="-400" Name="SynchronizingProject">Sincronizando o projeto %1.</Message>
    <Message Id="-401" Name="CheckingExtraneousItems">Verificando presen√ßa de itens √≥rf√£os no projeto.</Message>
    <Message Id="-402" Name="TotalExtraneousItems">Total de itens √≥rf√£os detectados: %1.</Message>
    <Message Id="-403" Name="NoExtraneousItems">Nenhum item √≥rf√£o encontrado.</Message>
    <Message Id="-404" Name="RemovingFile">Removendo item %1 (arquivo).</Message>
    <Message Id="-405" Name="RemovingDirectory">Removendo item %1 (diret√≥rio).</Message>
    <Message Id="-406" Name="TotalExtraneousItemsRemoved">Total de itens √≥rf√£os removidos: %1.</Message>
    <Message Id="-500" Name="Done"> feito.</Message>
    <Message Id="-501" Name="DoneWithErrors"> feito, mas com erros.</Message>
    <Message Id="-501" Name="Failed"> falhou.</Message>
    <Message Id="-502" Name="AllDone">Terminado com sucesso.</Message>
    <Message Id="-503" Name="KeepCacheExtension">manter seu formato original.</Message>
    <Message Id="-504" Name="OvewriteWithExtension">terminar com a extens√£o %1.</Message> 
    <Message Id="-600" Name="ImportingType">Importando %1 %2 ...</Message>
    <Message Id="-601" Name="EnqueingType">Enfileirando o %1 escolhido para ser importado ...</Message>
    <Message Id="-602" Name="NothingToImport">Nada para importar foi encontrado.</Message>
    <Message Id="-603" Name="ImportingProject">Importando o projeto %1.</Message>
    <Message Id="-604" Name="EnqueueingItems">Enfilerando itens para serem importados.</Message>
    <Message Id="-605" Name="TotalItemsToImport">Total de itens para importar: %1.</Message>
    <Message Id="-606" Name="NoPendingItemsToImport">N√£o h√° itens para serem importados.</Message>
    <Message Id="-607" Name="NewProject">O projeto %1 ainda n√£o existe e ser√° criado a seguir.</Message>
    <Message Id="-608" Name="FatalErrorAlert">FATAL: O seguintes erros impediram o projeto de ser importado:</Message>
    <Message Id="-609" Name="FatalRollbackAlert">As altera√ß√µes ser√£o desfeitas nas etapas a seguir.</Message>
    <Message Id="-610" Name="FatalProjectIntegrityRiskWarning">AVISO! N√ÉO INTERROMPA O PROCESSO PARA N√ÉO COMPROMETER A INTEGRIDADE DO PROJETO!</Message>
    <Message Id="-611" Name="FatalRollingBackTransaction">Descartando a transa√ß√£o pendente ...</Message>
    <Message Id="-612" Name="FatalApplyingBackup">Aplicando o backup para reverter altera√ß√µes no caminho da aplica√ß√£o.</Message>
    <Message Id="-613" Name="FatalFailedToRestoreBackup">ERRO: N√£o foi poss√≠vel aplicar o backup inteiramente devido a um erro de sistema. O backup ser√° mantido para uma corre√ß√£o manual.</Message>
    <Message Id="-614" Name="ProjectSaved">O projeto %1 foi salvo com %2 itens.</Message>
    <Message Id="-700" Name="CannotUseDefault">N√£o √© permitido o uso de projetos 'Default'. Se voc√™ deseja usar este projeto, voc√™ precisa fornecer outro nome utilizando Arquivo->Salvar Como.</Message>
    <Message Id="-701" Name="CannotUseDefault2">Todos os eventos foram desativados.</Message>
    <Message Id="-800" Name="ClassType">classe</Message>
    <Message Id="-801" Name="ProjectType">projeto</Message>
    <Message Id="-802" Name="RoutineType">rotina</Message>
    <Message Id="-803" Name="FileType">arquivo</Message>
    <Message Id="-804" Name="DirectoryType">diret√≥rio</Message>
    <Message Id="-805" Name="MACGroupType">rotinas macro</Message>
    <Message Id="-806" Name="INCGroupType">arquivos de inclus√£o</Message>
    <Message Id="-807" Name="INTGroupType">rotinas intermedi√°rias</Message>
    <Message Id="-808" Name="BASGroupType">rotinas Basic</Message>
    <Message Id="-809" Name="MVBGroupType">rotinas MV Basic</Message>
    <Message Id="-810" Name="MVIGroupType">rotinas MVI</Message>
    <Message Id="-811" Name="DFIGroupType">arquivos DFI</Message>
    <Message Id="-812" Name="CLSGroupType">classes</Message>
    <Message Id="-813" Name="FileGroupType">arquivos</Message>
    <Message Id="-900" Name="ExportingXML">Exportando o projeto %1 para XML ...</Message>
    <Message Id="-901" Name="XMLExportedTo">XML do projeto %1 exportado para %2.</Message>
    <Message Id="-902" Name="ExportingTestClassToXML">Exportando a classe de teste %1 ...</Message>
    <Message Id="-1000" Name="ConflictingItemDetected">CUIDADO! Foi detectada a presen√ßa do item %1 nos seguintes projetos: %2.</Message>
    <Message Id="-1001" Name="ConflictingItemDetected2">√â extremamente recomendado manter o item exclusivo a um projeto!</Message>
    <Message Id="-1100" Name="RunningCustomHook">Executando extens√£o do evento %1 da classe %2 ...</Message>
    <Message Id="-1101" Name="HookReturnedOK">%1 retornou sem erros.</Message>
    <Message Id="-1102" Name="HookReturnedError">Falhou ao executar %1 devido ao seguinte motivo: %2</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Menu Labels">
    <Message Id="-5000" Name="MLExport">Exportar</Message>    
    <Message Id="-5001" Name="MLExportToXML">Exportar para XML</Message>
    <Message Id="-5002" Name="MLExportTests">Exportar testes</Message>
    <Message Id="-5003" Name="MLRemoveClasses">Remover classes</Message>
    <Message Id="-5004" Name="MLRemoveFiles">Remover arquivos</Message>
    <Message Id="-5005" Name="MLRemoveRoutines">Remover rotinas</Message>
    <Message Id="-5006" Name="MLScanAndFix">Verificar e corrigir</Message>
    <Message Id="-5007" Name="MLRunTests">Executar testes</Message>
    <Message Id="-5008" Name="MLImport">Importar</Message>
    <Message Id="-5009" Name="MLForceExport">Exportar (for√ßado)</Message>
    <Message Id="-5010" Name="MLForceImport">Importar (for√ßado)</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Context Menu Labels">
    <Message Id="-6000" Name="CMLExportActive">Exportar a partir deste item</Message>
    <Message Id="-6001" Name="CMLImportActive">Importar a partir deste item</Message>
    <Message Id="-6002" Name="CMLRunActiveTest">Executar teste</Message>
  </MsgDomain>
  <MsgDomain Domain="Port Configuration Wizard">
    <Message Id="-7000" Name="PCWWelcome">Bem-vindo ao assistente de configura√ß√£o do Port.</Message>
    <Message Id="-7001" Name="PCWInvalidChoice">Escolha inv√°lida.</Message>
    <Message Id="-7002" Name="PCWChoiceQuestion">O que voc√™ deseja fazer? (digite o n√∫mero)</Message>
    <Message Id="-7003" Name="PCWChoicePrompt">Sua escolha: </Message>
    <Message Id="-7004" Name="PCWAborted">Abortado.</Message>
    <Message Id="-7005" Name="PCWToggleEnabled">ATIVADO</Message>
    <Message Id="-7006" Name="PCWToggleDisabled">DESATIVADO</Message>
    <Message Id="-7007" Name="PCWBye">At√© mais.</Message>
    <Message Id="-7100" Name="PCWManageWorkspaceChoice">1. Gerenciar espa√ßos de trabalho.</Message>
    <Message Id="-7101" Name="PCWManageWorkspaceDescription">Gerencia espa√ßos de trabalho que ir√£o conter o c√≥digo-fonte.</Message>
    <Message Id="-7110" Name="PCWManageWorkspaceChoice1">1. Alterar espa√ßo de trabalho padr√£o.</Message>
    <Message Id="-7111" Name="PCWManageWorkspaceChoice1Description">Altera o espa√ßo de trabalho utilizado por padr√£o. Aplic√°vel somente para novos projetos.</Message>
    <Message Id="-7112" Name="PCWManageWorkspaceChoice1StatusCurrent">O espa√ßo de trabalho padr√£o atual √© %1.</Message>
    <Message Id="-7113" Name="PCWManageWorkspaceChoice1StatusNow">O espa√ßo de trabalho padr√£o agora √© %1.</Message>
    <Message Id="-7120" Name="PCWManageWorkspaceChoice2">2. Gerencia espa√ßos de trabalho existentes.</Message>
    <Message Id="-7121" Name="PCWManageWorkspaceChoice2Description">Gerencia espa√ßos de trabalhos vinculados a projetos j√° existentes ou de antem√£o.</Message>
    <Message Id="-7122" Name="PCWManageWorkspaceChoice2Description2">Esta configura√ß√£o sobreescrever√° o espa√ßo de trabalho padr√£o para o projeto escolhido.</Message>
    <Message Id="-7123" Name="PCWManageWorkspaceChoice2Prompt">Digite o nome do projeto (ou deixe vazio para abortar):</Message>
    <Message Id="-7124" Name="PCWManageWorkspaceChoice2Warning">AVISO: O projeto %1 ainda n√£o existe."</Message>
    <Message Id="-7125" Name="PCWManageWorkspaceChoice2StatusCurrent">Espa√ßo de trabalho atual para este projeto: %1.</Message>
    <Message Id="-7126" Name="PCWManageWorkspaceChoice2CurrentWorskpaceWarn">Ser√° requisitado um novo espa√ßo de trabalho a seguir.</Message>
    <Message Id="-7127" Name="PCWManageWorkspaceChoice2Prompt2">Digite o caminho do espa√ßo de trabalho (ou deixe vazio para abortar):</Message>
    <Message Id="-7128" Name="PCWManageWorkspaceChoice2StatusNow">O projeto %1 agora est√° configurado para ser exportado no caminho: %2.</Message>
    <Message Id="-7200" Name="PCWManageChangeTestSettingsChoice">2. Alterar configura√ß√µes de teste.</Message>
    <Message Id="-7201" Name="PCWManageChangeTestSettingsDescription">Altera configura√ß√µes relacionadas √† integra√ß√£o do Studio com a API de testes.</Message>
    <Message Id="-7210" Name="PCWManageChangeTestSettingsChoice1">1. Ativar ou desativar testes por demanda.</Message>
    <Message Id="-7211" Name="PCWManageChangeTestSettingsChoice1Description">Quando esta configura√ß√£o estivar ativa, Port ir√° tentar encontrar a classe de teste da classe em edi√ß√£o e executar seus testes ap√≥s sua compila√ß√£o.</Message>
    <Message Id="-7212" Name="PCWManageChangeTestSettingsChoice1Choice1">1. Ativar testes por demanda.</Message>
    <Message Id="-7213" Name="PCWManageChangeTestSettingsChoice1Choice2">2. Desativar testes por demanda.</Message>
    <Message Id="-7214" Name="PCWManageChangeTestSettingsChoice1StatusCurrent">Testes por demanda est√° atualmente %1.</Message>
    <Message Id="-7220" Name="PCWManageChangeTestSettingsChoice2">2. Definir um novo pref√≠xo para classes de teste.</Message>
    <Message Id="-7221" Name="PCWManageChangeTestSettingsChoice2Description">Um prefixo √© requirido para informar ao Port qual pacote deve ser considerado como um pacote com classes de teste.</Message>
    <Message Id="-7222" Name="PCWManageChangeTestSettingsChoice2Description2">Este pref√≠xo √© utilizado como uma forma de equival√™ncia.</Message>
    <Message Id="-7223" Name="PCWManageChangeTestSettingsChoice2Description3">Ex: UnitTest.MyPackage.MyClass -> MyPackage.MyClass.</Message>
    <Message Id="-7224" Name="PCWManageChangeTestSettingsChoice2Prompt">Por favor digite o pref√≠xo abaixo. Note que pref√≠xos tamb√©m pode ser compostos. Ex: Package.UnitTest.</Message>
    <Message Id="-7225" Name="PCWManageChangeTestSettingsChoice2StatusNow">O pref√≠xo agora √©: %1.</Message>
    <Message Id="-7230" Name="PCWManageChangeTestSettingsChoice3">3. Alterar caminho para classes de teste (XML).</Message>
    <Message Id="-7231" Name="PCWManageChangeTestSettingsChoice3Description">Define o caminho ra√≠z aonde as classes de testes ser√£o hierarquicamente exportadas.</Message>
    <Message Id="-7232" Name="PCWManageChangeTestSettingsChoice3StatusNow">O caminho para classes de teste agora √©: %1.</Message>
    <Message Id="-7300" Name="PCWToggleAutoExportChoice">3. Ativar ou desativar a exporta√ß√£o autom√°tica do XML do projeto.</Message>
    <Message Id="-7301" Name="PCWToggleAutoExportDescription">Exporta um arquivo XML quando o projeto ou um item dele √© salvo.</Message>
    <Message Id="-7302" Name="PCWToggleAutoExportChoice1StatusCurrent">Exporta√ß√£o autom√°tica est√° atualmente como %1.</Message>
    <Message Id="-7303" Name="PCWToggleAutoExportChoice1StatusNow">Exporta√ß√£o autom√°tica agora est√° como %1.</Message>
    <Message Id="-7310" Name="PCWToggleAutoExportChoice1">1. Ativar exporta√ß√£o autom√°tica do XML.</Message>
    <Message Id="-7320" Name="PCWToggleAutoExportChoice2">2. Desativar exporta√ß√£o autom√°tica do XML.</Message>
    <Message Id="-7400" Name="PCWSetLogLevelChoice">4. Definir n√≠vel de log.</Message>
    <Message Id="-7401" Name="PCWSetLogLevelDescription">Especifica o n√≠vel de verbosidade utilizado no log de opera√ß√µes.</Message>
    <Message Id="-7402" Name="PCWSetLogLevelStatusCurrent">N√≠vel de verbosidade atual do log: %1.</Message>
    <Message Id="-7403" Name="PCWSetLogLevelStatusNow">O n√≠vel de verbosidade do log agora √©: %1.</Message>
    <Message Id="-7404" Name="PCWSetLogLevelStatusPrompt">Por favor escolha o n√≠vel de verbosidade do log (digite o n√∫mero): </Message>
    <Message Id="-7410" Name="PCWSetLogLevelStatusChoice1">1. N√≠vel 1: Exibe enfileiramento, categorias de importa√ß√£o/exporta√ß√£o, notifica√ß√µes de backup, situa√ß√£o do espa√ßo de trabalho e mensagens de erro.</Message>
    <Message Id="-7420" Name="PCWSetLogLevelStatusChoice2">2. N√≠vel 2: Inclui toda a verbosidade do n√≠vel 1, substituindo categorias por notifica√ß√µes por item.</Message>
    <Message Id="-7500" Name="PCWSetSourceExtensionChoice">5. Definir extens√£o do fonte.</Message>
    <Message Id="-7501" Name="PCWSetSourceExtensionDescription">Define uma extens√£o para ser inserida no final do arquivo.</Message>    
    <Message Id="-7502" Name="PWCSetSourceExtensionPrompt">Por favor digite a extens√£o abaixo:</Message>
    <Message Id="-7503" Name="PWCSetSourceExtensionStatusNow">A extens√£o agora √©: %1</Message>
    <Message Id="-7600" Name="PCWExit">6. Sair.</Message>
    <Message Id="-7970" Name="PCWPlaceholdersAnnounce">Voc√™ pode utilizar os seguinte marcadores:</Message>
    <Message Id="-7971" Name="PCWPlaceholdersProject">{PROJECT} - O nome do projeto ativo.</Message>
    <Message Id="-7972" Name="PCWPlaceholdersNamespace">{NAMESPACE} - O namespace ativo.</Message>
    <Message Id="-7973" Name="PCWPlaceholdersUsername">{USERNAME} - O login do usu√°rio que iniciou o processo.</Message>
    <Message Id="-7974" Name="PCWPlaceholdersInstallDir">{INSTALLDIR} - O diret√≥rio de instala√ß√£o.</Message>
    <Message Id="-7980" Name="PCWPathRelative">Por favor digite o caminho RELATIVO a ser utilizado ao exportar os arquivos de teste. Os caminhos devem ser relativos √† raiz do projeto exportado. (Ou deixe vazio para usar o padr√£o)</Message>
    <Message Id="-7981" Name="PCWPathAbsolute">Por favor digite o caminho ABSOLUTO a ser utilizado ao exportar o c√≥digo-fonte. (Ou deixe vazio para usar o padr√£o)</Message>
    <Message Id="-7982" Name="PCWPathOSSchemes">Voc√™ pode usar ambos: esquemas *NIX ou Windows.</Message>
    <Message Id="-7983" Name="PCWPathDefault">Padr√£o √©:</Message>
    <Message Id="-7984" Name="PCWPathCurrent">Atual √©:</Message>
    <Message Id="-7985" Name="PCWPathNew">Novo: </Message>
    <Message Id="-7999" Name="PCWGoBackChoice">%1. Retornar.</Message>
  </MsgDomain>  
</MsgFile>
]]></Data>
</XData>

<Method name="Uninstall">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if '$data(^Port.Configuration("installed")) {
    return $$$PERROR($$$PortIsNotInstalled, $namespace)
  }
  
  write "Removing Port, please wait ...", !
  set sc = $$$OK
  do ##class(Port.Configuration).Uninstall()
  do ##class(Port.SourceControl.Log).Flush()
  set sc = $$$ADDSC(sc, ##class(%Studio.SourceControl.Interface).SourceControlClassSet($get(^Port.Configuration("old")), $namespace))
  set sc = $$$ADDSC(sc, ##class(Port.SourceControl.LogCleaner).RemoveTask())
  set sc = $$$ADDSC(sc, ..RemoveGlobalMapping())  
  if $$$ISOK(sc) write $$$FormatText("Port has been removed from %1.", $namespace), !
  else  write "One or more errors ocurred while removing Port:", !!, $System.Status.GetErrorText(sc)
  return $$$OK
]]></Implementation>
</Method>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<FormalSpec>force:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  
  if 'force {
    if $data(^Port.Configuration("installed")) {
      write "Port is already installed. The installer has been aborted.", !
      write "If you wish to change current settings then please use the wizard (Wizard^Port) or call this method with force=1.", !!
      return $$$ERROR($$$GeneralError, "Port is already installed.")
    }
  }
  
  try {
    write !, "Installing Port ... please wait a moment.", !
    write $$$FormatText("> Retrieving physical path for %1's default web application ...", $namespace), !
    $$$ThrowOnError(..GetWebAppPhysicalPath(.path))
    set ^Port.Configuration("internals.webapp.path") = path
    write "> Creating Message Dictionary ... ", !, ">"
    $$$ThrowOnError(..CreateMessageDictionary())
    write "> Creating global mappings ...", !   
    $$$ThrowOnError(..CreateGlobalMapping())
    write "> Setting up workspace structure ... ", !
    do ##class(Port.Configuration).SetPrimaryWorkspace("/CacheProjects/{NAMESPACE}/{PROJECT}")
    write "> Setting up test files directory ...", !
    do ##class(Port.Configuration).SetTestPath("tests/cls")
    write "> Defining default test class prefix ..", !
    do ##class(Port.Configuration).SetTestClassPrefix("UnitTest")
    write "> Configuring to run tests automatically ...", !
    do ##class(Port.Configuration).EnableTestOnDemand()
    write "> Configuring to export the project to XML automatically ...", !
    do ##class(Port.Configuration).EnableAutoExportXML()
    write "> Configuring log verbosity level to recommended level ...", !
    do ##class(Port.Configuration).SetLogLevel(1)
    write "> Registering source control log cleaner task for "_$namespace_" ...", !
    $$$ThrowOnError(##class(Port.SourceControl.LogCleaner).StartTask())
    write "> Installing %SourceControl hooks and activating it ...", !!
    set ^Port.Configuration("old.sourcecontrol") = ##class(%Studio.SourceControl.Interface).SourceControlClassGet($namespace)
    $$$ThrowOnError(##class(%Studio.SourceControl.Interface).SourceControlClassSet("Port.SourceControl.Hooks", $namespace))
    write "ALL DONE.", !
    write "NOTE: You must restart Studio in order to make the source control hooks work as expected."
    set ^Port.Configuration("installed") = 1
  } catch ex {
    set sc = ex.AsStatus()    
    write !!, "FATAL: Failed to install port due to the following reason: "
    do $System.OBJ.DisplayError(sc)
  }
  return sc
]]></Implementation>
</Method>

<Method name="CreateGlobalMapping">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set thisNamespace = $namespace     
  new $namespace
  
  set $namespace = "%SYS"
  
  if ##class(Config.MapGlobals).Exists(thisNamespace, "Port.SourceControl*") {
    write "> Global is already mapped. Skipping ...", !
    return $$$OK
  }
  
  try {
    $$$ThrowOnError(##class(Config.Namespaces).Get(thisNamespace, .nsProperties))
    set glProperties("Database") = thisNamespace
    $$$ThrowOnError(##class(Config.MapGlobals).Create(thisNamespace, "Port.SourceControl*", .glProperties))    
  } catch ex {
    set sc = ex.AsStatus()
  }
  set $namespace = thisNamespace
  return sc
]]></Implementation>
</Method>

<Method name="RemoveGlobalMapping">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set thisNamespace = $namespace     
  new $namespace
  
  set $namespace = "%SYS"  
  
  if ##class(Config.MapGlobals).Exists(thisNamespace, "Port.SourceControl*") {
    return ##class(Config.MapGlobals).Delete(thisNamespace, "Port.SourceControl*")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetWebAppPhysicalPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>*path:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set currentNS = $namespace  
  
  try {
    set $namespace = "%SYS"
    $$$ThrowOnError(##class(Security.Applications).Get($System.CSP.GetDefaultApp(currentNS), .settings))
  } catch ex {
    set sc = ex.AsStatus()
  }
  set path = ##class(%File).NormalizeFilename(settings("Path"))
  set $namespace = currentNS
  return sc
]]></Implementation>
</Method>

<Method name="CreateMessageDictionary">
<ClassMethod>1</ClassMethod>
<CodeMode>objectgenerator</CodeMode>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  do %code.WriteLine("  k ^CacheMsg(""Port Errors""),^CacheMsgNames(""Port Errors"")")
  do %code.WriteLine("  k ^CacheMsg(""Port Log Messages""), ^CacheMsgNames(""Port Log Messages"")")
  do %code.WriteLine("  k ^CacheMsg(""Port Menu Labels""), ^CacheMsgNames(""Port Menu Labels"")")
  do %code.WriteLine("  k ^CacheMsg(""Port Context Menu Labels""), ^CacheMsgNames(""Port Context Menu Labels"")")
  
  set XDatas = %compiledclass.XDatas
  
  for i=1:1:XDatas.Count() {
    set XDataId = $$$quote(%compiledclass.Name_"||"_XDatas.GetAt(i).Name)    
    do %code.WriteLine("  set localeXData = ##class(%Dictionary.CompiledXData).%OpenId("_XDataId_").Data")
    do %code.WriteLine("  set tmpFilename = ##class(%File).TempFilename(""xml"")")
    do %code.WriteLine("  set file = ##class(%Stream.FileCharacter).%New()")
    do %code.WriteLine("  set file.TranslateTable = ""UTF8""")
    do %code.WriteLine("  $$$QuitOnError(file.LinkToFile(tmpFilename))")
    do %code.WriteLine("  $$$QuitOnError(file.CopyFrom(localeXData))")
    do %code.WriteLine("  $$$QuitOnError(file.%Save())")
    do %code.WriteLine("  $$$QuitOnError(##class(%MessageDictionary).Import(tmpFilename))")
    do %code.WriteLine("  do ##class(%File).Delete(tmpFilename)")
    do %code.WriteLine("  set (localXData, tmpFilename, file) = """"")    
  }
  do %code.WriteLine("  $$$QuitOnError(##class(%MessageDictionary).GenerateInclude(""portmd"",,,""Port Errors,Port Log Messages,Port Menu Labels,Port Context Menu Labels""))")
  do %code.WriteLine("  return $$$OK")
]]></Implementation>
</Method>
</Class>


<Class name="Port.Logger">
<IncludeCode>portutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64306,37945.966346</TimeCreated>

<Property name="LogLevel">
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="Silent">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>logLevel:%Integer=2</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ((logLevel < 1) || (logLevel > 2)) {    
    $$$ThrowOnError($$$PERROR($$$LogLevelIsOutOfRange, logLevel, "1, 2")) 
  }
  set ..LogLevel = logLevel  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Log">
<FormalSpec>messageCode:%String,messageLogLevel=2,params...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if ..Silent || (..LogLevel < messageLogLevel) return ""
  if '$data(params) set params = 0    
  set formattedParams = 0 
  for i=1:1:params {
    set formattedParams = $increment(formattedParams)
    set formattedParams(formattedParams) = $$$FormatMessage($$$SessionLanguage, "Port Log Messages", params(i), params(i))
  }
  set msg = $$$FormatMsg("Port Log Messages", messageCode, formattedParams...)
  if messageCode '= $$$Done && (messageCode '= $$$Failed) set msg = "[Port] "_msg
  return msg
]]></Implementation>
</Method>

<Method name="LogLine">
<FormalSpec>messageCode:%String,messageLogLevel=2,params...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  if ..Silent || (..LogLevel < messageLogLevel) return ""
  return ..Log(messageCode, messageLogLevel, params...)_$c(13, 10)
]]></Implementation>
</Method>
</Class>


<Routine name="Port" type="MAC" languagemode="0"><![CDATA[
Install
  do ##class(Port.Installer).Install()
  quit

Wizard
  do ##class(Port.Wizard).Start()
  quit
]]></Routine>


<Class name="Port.Project.Backup">
<IncludeCode>portutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64306,37561.640431</TimeCreated>

<Property name="BackupDirectory">
<Type>%String</Type>
<Internal>1</Internal>
<Private>1</Private>
</Property>

<Property name="Logger">
<Type>Port.Project.Importer</Type>
</Property>

<Property name="IsRequired">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ImportList">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Method name="%OnNew">
<FormalSpec>backupDir:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..BackupDirectory = backupDir
  set ..Logger = ##class(Port.Logger).%New()
  quit $$$OK
]]></Implementation>
</Method>

<Method name="Create">
<FormalSpec><![CDATA[&list:%String=0]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set sc = $$$OK
  set itemName = ""
  set backupCount = 0
  set appPath = $System.CSP.GetDefaultApp($namespace)
  set appPath = $extract(appPath, 2, *)
  set backupFolderIsCreated = 0
  
  if '..IsRequired quit $$$OK
  
  write ..Logger.Log($$$BackupStart), !
  write ..Logger.Log($$$BackupAlert), !
  write ..Logger.Log($$$BackupMirror, 1)
  
  do Scan(9,  "CSR", .created)
  do Scan(10, "CSP", .created)
  
  if $$$ISOK(sc) write ..Logger.Log($$$Done, 1), !
  else  write ..Logger.Log($$$Failed, 1), !
  return sc  


Scan(group, type, created)
  set itemName = ""
  set created  = 0   
  for {
    set itemName = $order(list(group, type, itemName), 1, paths)
    quit:itemName=""
    
    set backupOrigin = $listget(paths, 2)
    set newVersion = $listget(paths, 1)
    // TODO: Add extra check to avoid backing up files that are not really outdated.
    // Don't backup or remove anything if target file is not present in the project
    // or doesn't exists in the app.
    if '(##class(%File).Exists(backupOrigin) && ##class(%File).Exists(newVersion)) {
      continue
    }
    set backupDestination = ##class(%File).NormalizeFilename(..BackupDirectory_"/"_$replace(itemName, appPath, ""))
    set parentBackupDirectory = ##class(%File).GetDirectory(backupDestination)
    set sc = ##class(Port.Util).CreateMissingPath(parentBackupDirectory)
    if $$$ISERR(sc) quit
    
    set created = 1    
    set isCopied = ##class(%File).CopyFile(backupOrigin, backupDestination, 1)
    set isDeleted = ##class(%File).Delete(backupOrigin)
    if isCopied = 0 || (isDeleted = 0) {
      set sc = $$$ADDSC(sc, $$$PERROR($$$UnableToCopySource, itemName, backupDestination))
    }   
  }
  if 'created {
    set ..IsRequired = 0
  }
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Base">
<IncludeCode>portutils,portmd</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64306,34528.425857</TimeCreated>

<Property name="Logger">
<Type>Port.Logger</Type>
</Property>

<Property name="ProjectName">
<Type>%String</Type>
</Property>

<Property name="Project">
<Type>%Studio.Project</Type>
<Private>1</Private>
</Property>

<Property name="Slash">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="BasePath">
<Type>%String</Type>
</Property>

<Property name="IncPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="ClassPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="IntPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MacPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="WebPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MvbPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="MviPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="BasPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="DfiPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="AffectedCount">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="IsBatch">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="Overwrite">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="LogLevel">
<Type>%Integer</Type>
<InitialExpression>2</InitialExpression>
</Property>

<Property name="SourceExtension">
<Type>%String</Type>
<InitialExpression>"txt"</InitialExpression>
</Property>

<Property name="IgnoredPaths">
<Type>%String</Type>
<Collection>list</Collection>
</Property>

<Method name="%OnNew">
<FormalSpec>target:%String,logLevel:%Integer=2,sourceExtension=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if target = "" {
    throw ##class(%Exception.StatusException).CreateFromStatus($$$ERROR(5001, "No target specified."))
  }
  
  set ..Slash = $select($$$isWINDOWS : "\", 1: "/")
  
  if (target [ "/") || (target [ "\") {
    $$$ThrowOnError(##class(Port.Util).GetProjectFromResolvedPath(target , .project))
    set fullProjectPath = ##class(%File).NormalizeFilename(target)  
    set ..ProjectName = project.Name    
    set ..BasePath = ##class(%File).NormalizeFilename(fullProjectPath)
    set ..Project = project
    set ..Logger = ##class(Port.Logger).%New(logLevel) 
    set ..SourceExtension = sourceExtension
    do ..BuildTypePaths(..BasePath)
    return $$$OK 
  }
  return $$$PERROR($$$CannotUseRelativePath)
]]></Implementation>
</Method>

<Method name="LogExclusive">
<Internal>1</Internal>
<FormalSpec>message:%String,logLevel:%Integer,params...:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if ..Logger.LogLevel '= logLevel return ""
  return ..Log(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="Log">
<Internal>1</Internal>
<FormalSpec>message:%Boolean,logLevel:%Integer=1,params...:%String</FormalSpec>
<Implementation><![CDATA[  return ..Logger.Log(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="LogLine">
<Internal>1</Internal>
<FormalSpec>message:%Boolean,logLevel:%Integer=1,params...:%String</FormalSpec>
<Implementation><![CDATA[
  
  return ..Logger.LogLine(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="LogExclusiveLine">
<Internal>1</Internal>
<FormalSpec>message:%Boolean,logLevel:%Integer=1,params...:%String</FormalSpec>
<Implementation><![CDATA[
  if ..Logger.LogLevel '= logLevel return ""
  return ..Logger.LogLine(message, logLevel, params...)
]]></Implementation>
</Method>

<Method name="GetProjectName">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return ..ProjectName
]]></Implementation>
</Method>

<Method name="Ignore">
<FormalSpec>ignoredPaths:%ArrayOfDataTypes=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK  
  
  if '$isobject(ignoredPaths) return sc
  if 'ignoredPaths.%IsA("%Collection.AbstractList") {
    return $$$ERROR($$$BadParameter, "ignoredPaths")
  }  
  
  for i=1:1:ignoredPaths.Count() {
    set absolutePath = ##class(%File).NormalizeFilename(..BasePath_"/"_ignoredPaths.GetAt(i))
    set sc = ..IgnoredPaths.Insert(absolutePath)
    if $$$ISERR(sc) quit
  }
  return sc
]]></Implementation>
</Method>

<Method name="IsIgnored">
<FormalSpec>maybeIgnoredPath:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
 
  set key = ""
  set isIgnored = 0
  
  for i=1:1:..IgnoredPaths.Count() {
    set path = ..IgnoredPaths.GetAt(i)
    set isIgnored = ((path = maybeIgnoredPath) || (maybeIgnoredPath [ path))
    if isIgnored quit
  }
  return isIgnored
]]></Implementation>
</Method>

<Method name="ResolvePathType">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>itemType:%String,itemName:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  #define Normalize(%path)    ##class(%File).NormalizeFilename(%path)
  
  if itemType = "CLS" return ..ClassPath
  if itemType = "INT" return ..IntPath
  if itemType = "INC" || (itemType = "MAC" && ($piece(itemName, ".", 2) = "INC")) {
    // InterSystems groups INC into MAC type, so we patch it checking the name instead.
    return ..IncPath
  }
  if itemType = "MAC" return ..MacPath  
  if itemType = "MVB" return ..MvbPath
  if itemType = "MVI" return ..MviPath  
  if itemType = "BAS" return ..BasPath
  if itemType = "DFI" return ..DfiPath
  return ""
]]></Implementation>
</Method>

<Method name="GetTypePath">
<FormalSpec>itemType:%String,itemName:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 
  if itemType = "CLS" return ..ClassPath
  if itemType = "INT" return ..IntPath
  if itemType = "INC" || (itemType = "MAC" && ($piece(itemName, ".", 2) = "INC")) {
    // InterSystems groups INC into MAC type, so we patch it checking the name instead.
    return ..IncPath
  }
  if itemType = "MAC" return ..MacPath
  if itemType = "CSP" return ..WebPath
  if itemType = "MVB" return ..MvbPath
  if itemType = "MVI" return ..MviPath  
  if itemType = "BAS" return ..BasPath
  if itemType = "DFI" return ..DfiPath
  if itemType = "PKG" return ..ClassPath
  return ..WebPath
]]></Implementation>
</Method>

<Method name="BuildTypePaths">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>workspacePath:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define BuildTypedPath(%type) workspacePath_$$$Slash(workspacePath)
  
  set ..ClassPath = $$$BuildTypedPath("cls")
  set ..IntPath   = $$$BuildTypedPath("int")
  set ..MacPath   = $$$BuildTypedPath("mac") 
  set ..IncPath   = $$$BuildTypedPath("inc")
  set ..WebPath   = $$$BuildTypedPath("web")  
  set ..MvbPath   = $$$BuildTypedPath("mvb")
  set ..MviPath   = $$$BuildTypedPath("mvi")
  set ..BasPath   = $$$BuildTypedPath("bas")  
  set ..DfiPath   = $$$BuildTypedPath("dfi")
  return $$$OK
]]></Implementation>
</Method>

<Method name="IsOutdated">
<FormalSpec>current:%String,external:%String,isImport:%Boolean=0</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[  return ##class(Port.Util).IsOutdated(..GetProjectName(), current, external)
]]></Implementation>
</Method>

<Method name="GetSourceExtension">
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[  return $select(..SourceExtension '= "" : "."_..SourceExtension, 1: "")
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Exporter">
<IncludeCode>portutils</IncludeCode>
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.610794</TimeCreated>

<Property name="ExportedPackages">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="Synchronizer">
<Type>Synchronizer</Type>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>path:%String,logLevel:%Integer=2,sourceExtension:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##super(path, logLevel, sourceExtension))  
       
  if '$isobject(..Project) {
    set ..ProjectName = "null"
    throw ##class(%Exception.StatusException).CreateFromStatus($$$PERROR($$$ExportingProjectNotFound, ..ProjectName))
  }
  set ..Synchronizer = ##class(Synchronizer).%New($this)
  return $$$OK
]]></Implementation>
</Method>

<Method name="Export">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set ..IsBatch = 1
  do ..Reset()
  
  write ..LogLine($$$ExportingProject, 0, ..Project.Name)
  
  $$$QuitOnError(..ExportProjectItems())
  
  if ..AffectedCount > 0 {
    write ..LogLine($$$SourceExportedToPath, 0, ..BasePath)
  } else {
    write ..LogLine($$$NoItemsToExport, 0, ..Project.Name)
  }
  
  write ..LogLine($$$SynchronizingProject, 0, ..Project.Name)
  
  $$$QuitOnError(..Synchronizer.Purge())
  
  write ..LogLine($$$AllDone, 0)
  return $$$OK
]]></Implementation>
</Method>

<Method name="ExportProjectItems">
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(..ProjectName, 1) 
  while r.%Next(.sc) {
    if $$$ISERR(sc) quit
    set itemName = r.%Get("Name")
    set itemType = r.%Get("Type")
    set sc = $$$ADDSC(sc, ..ExportItem(itemName, itemType))
  }
  return sc
]]></Implementation>
</Method>

<Method name="ExportItem">
<FormalSpec>itemName:%String,type:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ##class(Port.Util).IsRoutine(itemName) return ..ExportRoutine(itemName)
  
  set itemType = $case(type, "": ##class(Port.Util).ResolveItemExtension(itemName), : type)
  if itemType = "PKG" return ..ExportPackage(itemName)
  if itemType = "CLS" return ..ExportClass(itemName)
  
  return ..ExportWebFile(itemName)
]]></Implementation>
</Method>

<Method name="ExportPackage">
<FormalSpec>packageName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = ##class(Port.Util).MountIdFromName(packageName_".PKG", ..Project.Name)
  // Cannot assume that the package is always present in the project, 
  // even if the project has some classes from it.
  if '##class(%Studio.ProjectItem).%ExistsId(id) return $$$OK
  
  if $listfind(i%ExportedPackages, packageName) return $$$OK  
  
  set classList = $System.OBJ.GetPackageList(.classList, packageName)
  set className = ""
  set sc = $$$OK
  for {
    set className = $order(classList(className))
    quit:className=""
    set err = ..ExportClass(className, 1)
    if $$$ISERR(err) {
      if $$$ISOK(sc) set sc = err
      else  set sc = $$$ADDSC(sc, err)
    }
  }
  set $list(i%ExportedPackages, *+1) = packageName
  return sc
]]></Implementation>
</Method>

<Method name="ExportWebFile">
<FormalSpec>itemName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = ##class(Port.Util).MountIdFromName(itemName, ..Project.Name)  
  if '##class(%Studio.ProjectItem).%ExistsId(id) {
    return $$$PERROR($$$UnableToExportInvalidItem, itemName)
  }  
      
  $$$QuitOnError(##class(Port.Util).CSPLogicalToPhysicalPath(itemName, .source))
  set dest = ##class(Port.Util).GetItemSourcePathFromWorkspace(itemName, ..Project.Name)
  set path = ##class(%File).GetDirectory(dest) 
  
  $$$QuitOnError(##class(Port.Util).CreateMissingPath(path))
  $$$QuitOnError(..Synchronizer.AddToWhitelist(itemName))
  
  if ..Overwrite = 0 && '..IsOutdated(itemName, dest) return $$$OK
  
  write ..Log($$$ExportingType, 1, $$$FileType, dest)
  set exported = ##class(%File).CopyFile(source, dest, 1)  
  
  if exported = 0 {
    write ..LogLine($$$Failed)
    return $$$PERROR($$$UnableToCopySource, source, dest)
  }
  
  write ..LogLine($$$Done)
  set ..AffectedCount = ..AffectedCount + 1
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="ExportRoutine">
<FormalSpec>name:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set id = ##class(Port.Util).MountIdFromName(name, ..Project.Name)
  
  if '##class(%Studio.ProjectItem).%ExistsId(id) {
    return $$$PERROR($$$UnableToExportInvalidItem, name)
  }

  set dest = ##class(Port.Util).GetItemSourcePathFromWorkspace(name, ..Project.Name, ..SourceExtension)  
  set path = ##class(%File).GetDirectory(dest)
  
  $$$QuitOnError(..Synchronizer.AddToWhitelist(name))
  
  if '##class(%RoutineMgr).Exists(name) return $$$PERROR($$$UnableToExportInvalidItem, name)
  $$$QuitOnError(##class(Port.Util).CreateMissingPath(path))
      
  if ..Overwrite = 0 && '..IsOutdated(name, dest) return $$$OK
  
  write ..Log($$$ExportingType, 1, $$$RoutineType, name)
  
  set file = ##class(%Stream.FileCharacter).%New()
  set file.TranslateTable = "UTF8"
  do file.LinkToFile(dest)  
  
  set routine = ##class(%RoutineMgr).%OpenId(name)  
  set sc = file.CopyFrom(routine.Code)
  
  if $$$ISERR(sc) write ..LogLine($$$Failed) return sc 
  
  write ..LogLine($$$Done)
  
  $$$QuitOnError(file.%Save())
  
  set ..AffectedCount = ..AffectedCount + 1
  return $$$OK
]]></Implementation>
</Method>

<Method name="ExportClass">
<FormalSpec>className:%String,fromPackage:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  // Checks if this entry is coming from %SourceControl and fixes it removing the CLS type.
  if ##class(Port.Util).ResolveItemExtension(className) = "CLS" {
    set className = $piece(className, ".", 1, *-1)
  } 
  
  set itemName = className_".CLS"
  
  // Cannot export classes that don't belong to the project.
  set id = ##class(Port.Util).MountIdFromName(itemName, ..Project.Name)
  // Cannot check for the class item id if the call was delegated by ExportPackage.
  if 'fromPackage && '##class(Port.Util).ExistsInProject(..Project.Name, itemName) {
    return $$$PERROR($$$UnableToExportInvalidItem, itemName)
  }
  
  set package = $piece(itemName, ".", 1, *-1)
  set dest = ##class(Port.Util).GetItemSourcePathFromWorkspace(itemName, ..Project.Name, ..SourceExtension)
  set path = ##class(%File).GetDirectory(dest)  
  
  $$$QuitOnError(..Synchronizer.AddToWhitelist(itemName))
  if $listfind(..ExportedPackages, package) return $$$OK  
  
  $$$QuitOnError(##class(Port.Util).CreateMissingPath(path))
  
  if ..Overwrite = 0 && '..IsOutdated(itemName, dest) return $$$OK
  else  do ##class(%File).Delete(dest)
  
  write ..Log($$$ExportingType, 1, $$$ClassType, className)
  
  if '##class(%ClassDefinition).%ExistsId(className) {
    write ..LogLine($$$Failed)
    return $$$ERROR($$$UnableToExportInvalidItem, className)
  }
  
  $$$QuitOnError(##class(%Compiler.UDL.TextServices).GetTextAsStream($namespace, itemName, .stream))
  set file = ##class(%Stream.FileCharacter).%New()
  set file.TranslateTable = "UTF8"
  do file.LinkToFile(dest)
  $$$QuitOnError(file.CopyFromAndSave(stream))
  
  write ..LogLine($$$Done)
  
  set ..AffectedCount = ..AffectedCount + 1
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Reset">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%ExportedPackages = ""
  do ..Synchronizer.Reset()
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Importer">
<IncludeCode>portutils,%sySystem</IncludeCode>
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.722609</TimeCreated>

<Property name="IsNewProject">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
<Private>1</Private>
</Property>

<Property name="CSPPath">
<Type>%String</Type>
<Private>1</Private>
</Property>

<Property name="Backup">
<Type>Port.Project.Backup</Type>
<Private>1</Private>
</Property>

<Property name="BackupDirectory">
<Type>%String</Type>
<Internal>1</Internal>
</Property>

<Property name="SkipBackup">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Property name="ImportList">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="ItemsList">
<Type>%String</Type>
<InitialExpression>0</InitialExpression>
<MultiDimensional>1</MultiDimensional>
<Private>1</Private>
</Property>

<Method name="%OnNew">
<FormalSpec>inputPath:%String,logLevel:%Integer=2,sourceExtension:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##super(inputPath, logLevel, sourceExtension))
  
  set installDirectory = $System.Util.InstallDirectory()
  
  set ..CSPPath = ##class(Port.Configuration).GetWebAppPath()
  set ..BackupDirectory = $$$NFN(..BasePath_"/__backup__/")
  set ..Backup = ##class(Port.Project.Backup).%New(..BackupDirectory)
  set ..Backup.Logger = ..Logger
  
  set i%ImportList = 0
  set i%ItemsList = 0
  
  if '$isobject(..Project) {
    set ..IsNewProject = 1
    set ..Project = ##class(%Studio.Project).%New()
    set ..Project.Name = ..ProjectName
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="EnqueueAll">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..ResetLists()
  
  set sc = $$$OK
  for i = ..IncPath, ..IntPath, ..ClassPath, ..MacPath, ..BasPath, ..MviPath, ..MvbPath, ..DfiPath, ..WebPath {
    set sc = ..EnqueueDirectory(i)
    if $$$ISERR(sc) quit
  }
  return sc
]]></Implementation>
</Method>

<Method name="EnqueueItem">
<FormalSpec>target:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set isWebPath = target [ ..WebPath   
  
  $$$QuitOnError(..Describe(target, isWebPath, .described, .isOutdated, .internalFileName, .itemName, .itemType, .group, .alias))  
  
  if described && '$data(i%ItemsList(itemName)) {
    if '..Backup.IsRequired && '..SkipBackup && ((itemType = "CSP") || (itemType = "CSR") && isOutdated) {
      set ..Backup.IsRequired = 1
    }
    set i%ItemsList = $increment(i%ItemsList)
    set i%ItemsList(itemName) = ""  
        
    if isOutdated || ..Overwrite {
      set i%ImportList = $increment(i%ImportList)
      set i%ImportList(group, itemType, alias) = $listbuild(target, internalFileName)
    }        
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="EnqueueDirectory">
<FormalSpec>searchPath:%String,fs:%SQL.Statement=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  if '..IsBatch && '$isobject(fs) {
    do ..ResetLists()
  }
  
  if ..IsIgnored(searchPath) return $$$OK
  
  if '$isobject(fs) {
    set fs = ##class(%SQL.Statement).%New()
    $$$QuitOnError(fs.%PrepareClassQuery("%File", "FileSet"))
  }
  
  set sc = $$$OK
  set rows = fs.%Execute(searchPath)
  
  set slash = $$$Slash(searchPath)
  
  while rows.%Next(.sc) {
    if $$$ISERR(sc) return 
    set compilable = 0
    set type = rows.%Get("Type")
    set external = rows.%Get("Name")
    if type = "F" { 
      set sc = ..EnqueueItem(external) 
      if $$$ISERR(sc) quit
    } elseif type = "D" {
      set targetDir = $piece(external, slash, *)
      if '(targetDir?1".".AN) {
        set sc = ..EnqueueDirectory(external, fs)
        if $$$ISERR(sc) quit
      }
    }   
  }
  return sc
]]></Implementation>
</Method>

<Method name="GetTypePriority">
<Internal>1</Internal>
<FormalSpec>type:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
  if type = ".INC" return 1
  if type = ".INT" return 2
  if type = ".CLS" return 3
  if type = ".MAC" return 4
  if type = ".MVI" return 5
  if type = ".MVB" return 6
  if type = ".BAS" return 7
  if type = ".DFI" return 8
  if type = ".CSR" return 9
  return 10
]]></Implementation>
</Method>

<Method name="Describe">
<Internal>1</Internal>
<FormalSpec>origin:%String,isWebPath:%Boolean=0,described:%Boolean=0,*isOutdated:%Boolean=0,*itemDestination:%String,*itemName:%String,*itemType:%String,*priority:%String,*alias:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set described = 0 
  set extension = ..GetFileExtension(origin, isWebPath)
  set extSize = $length(..GetSourceExtension())
  
  if 'isWebPath $$$QuitOnError(..AssertValidExtension(origin))
  
  if '(extension?1".".AN) return described
  if extension = "" return described  
    
  set priority = ..GetTypePriority(extension)
  set pathType = ##class(Port.Util).ExtractType(origin, ..BasePath)    
  
  set isRoutineFromExtension = $lf($$$RoutineExtensions, extension)
  set isRoutineFromPath = $lf($$$RoutineExtensions,  "."_pathType)
  set isClassFromExtension = (extension = ".CLS")
  set isClassFromPath = pathType = "CLS" 
  
  if isClassFromExtension && isClassFromPath  {
    set itemType = "CLS"
    set itemDestination = ##class(Port.Util).FileToClass(origin)
    set itemName = itemDestination_extension
    set alias = itemDestination
    set described = 1
  } elseif isRoutineFromExtension && isRoutineFromPath {
    set itemType = $piece(extension, ".", 2)    
    set itemDestination = $extract(##class(%File).GetFilename(origin), 1, *-(4 + extSize))_extension
    set itemName = itemDestination
    set alias = itemName
    set described = 1
  } elseif 'isRoutineFromExtension && 'isRoutineFromPath && 'isClassFromExtension && (pathType = "WEB") {
    if extension = ".CSR" set itemType = "CSR"
    else  set itemType = "CSP"
    $$$QuitOnError(##class(Port.Util).CSPPhysicalToLogicalPath(origin, .logicalPath))
    $$$QuitOnError(##class(Port.Util).CSPLogicalToPhysicalPath(logicalPath, .physicalPath))
    set itemName = logicalPath
    set itemDestination = physicalPath    
    set alias = itemName
    set described = 1
  }
  
  if described && '..Overwrite {
    set isOutdated = ..IsOutdated(itemName, origin, 1)
  } else {
    set isOutdated = 1
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ImportList">
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK  
  
  for i=1:1:10 {
   set sc = ..ImportType(i)
   if $$$ISERR(sc) {
    set typeSC = $$$PERROR($$$ErrorsWhileImportingType, $listget($$$ImportTypeDescriptions, i))
    set typeSC = $$$EMBEDSC(typeSC, sc)
    return sc
   }
  }  
  return sc
]]></Implementation>
</Method>

<Method name="ImportType">
<Internal>1</Internal>
<FormalSpec>group:%Integer</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  if '$data(i%ImportList(group)) return sc  
  set itemType = $listget($$$ImportTypes, group, "CSP")
  
  write ..LogExclusive($$$ImportingType, 1, $$$GetGroupTypeDescription(itemType))
  
  set itemName = ""
  for {
    quit:'$data(i%ImportList(group))
    set itemName = $order(i%ImportList(group, itemType, itemName), 1, paths)
    quit:itemName=""
    
    set origin = $listget(paths, 1)
    set destination = $listget(paths, 2, itemName)
    
    write ..LogExclusive($$$ImportingType, 2, $$$GetTypeDescription(itemType), destination)
    
    set sc = ..ImportFromExternalSource(itemName, origin,  itemType, destination)
    if $$$ISERR(sc)  write ..LogExclusiveLine($$$Failed, 2) return sc
    else  write ..LogExclusiveLine($$$Done, 2)
  }
  write ..LogExclusiveLine($$$Done, 1)
  return sc
]]></Implementation>
</Method>

<Method name="ImportPartial">
<FormalSpec>target:%String,importedList:%String=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set sc = $$$OK
  
  set resolvedTarget = ##class(%File).NormalizeFilename(target, ..BasePath)
  
  if (resolvedTarget = ..BasePath) {
    return $$$PERROR($$$AmbiguousPartialToWorkspace, resolvedTarget)
  }
  
  if '(resolvedTarget [ ..ClassPath || (resolvedTarget [ ..IncPath) ||
      (resolvedTarget [ ..IncPath)  || (resolvedTarget [ ..MacPath) ||
      (resolvedTarget [ ..WebPath)
  ) { 
    return $$$PERROR($$$SupressedAttemptToExportFromOutside)
  }  
  
  if ##class(%File).DirectoryExists(resolvedTarget) {
    write ..Log($$$EnqueingType, 1, $$$DirectoryType)
    set sc = ..EnqueueDirectory(resolvedTarget)
  } elseif ##class(%File).Exists(resolvedTarget) {
    write ..Log($$$EnqueingType, 1, "item")
    set sc = ..EnqueueItem(resolvedTarget)
  } else {
    write ..Log($$$NothingToImport)
    return sc
  }
  
  if sc {
    write ..LogLine($$$Done)
    set sc = ..Import()
    if $$$ISOK(sc) {
      set importedList = i%ImportList
      merge importedList = i%ImportList
    }
  } else {
    write ..LogLine($$$Failed)
  }  
  return sc
]]></Implementation>
</Method>

<Method name="Import">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set onlyPopulateProject = 0
  set ..AffectedCount = 0              
  
  tstart
  
  try {       
    if ..IsBatch {
      write ..LogLine($$$ImportingProject, 0, ..Project.Name)
      write ..LogLine($$$EnqueueingItems, 0)
      $$$ThrowOnError(..EnqueueAll())
    }       
      
    if i%ImportList > 0 {
      write ..LogLine($$$TotalItemsToImport, 0, i%ImportList)
      merge list = i%ImportList
      if '..SkipBackup $$$ThrowOnError(..Backup.Create(.list))        
      $$$ThrowOnError(..ImportList())
    } else {
      write ..LogLine($$$NoPendingItemsToImport, 0)
    }
         
    if ..IsNewProject {
      write ..LogLine($$$NewProject, 0, ..Project.Name)
    }
    
    if i%ImportList > 0 {
      write ..LogLine($$$SynchronizingProject, 0, ..Project.Name)
      $$$ThrowOnError(..SynchronizeProject())
      write ..LogLine($$$ProjectSaved, 0, ..Project.Name, ..Project.Items.Count())
    }
    
    set ..AffectedCount = i%ImportList           
    
    if ..Backup.IsRequired && '..SkipBackup {
      // If anything is ok until here, then delete the backup.
      write ..Log($$$RemovingBackupMirror, 0)
      set isRemoved = ##class(%File).RemoveDirectoryTree(..BackupDirectory)
      if isRemoved {
        write ..LogLine($$$Done, 0)
        set ..Backup.IsRequired = 0
      } else  {
        write ..LogLine($$$Failed, 0)
        $$$ThrowOnError($$$PERROR(UnableToRemoveDirectory, ..BackupDirectory))
      }
    }    
    tcommit
  } catch ex {
    set sc = ex.AsStatus()
    write !!, ..LogLine($$$FatalErrorAlert, 0)
    write $System.Status.GetErrorText(sc), !!
    
    write ..LogLine($$$FatalRollbackAlert, 0), !
    write ..LogLine($$$FatalProjectIntegrityRiskWarning, 0)
    write ..Log($$$FatalRollingBackTransaction, 0)
    
    trollback
    write ..LogLine($$$Done, 0)
    
    if ..Backup.IsRequired {
      write ..LogLine($$$FatalApplyingBackup, 0)
      set isCopied = ##class(%File).CopyDir(..BackupDirectory, ..CSPPath, 1)
      if 'isCopied { 
        write ..LogLine($$$FatalFailedToRestoreBackup, 0)
        set sc = $$$ADDSC(sc, $$$PERROR($$$UnableToCopySource, ..BackupDirectory, ..CSPPath))
      }  
    }
  }
  return sc
]]></Implementation>
</Method>

<Method name="ImportFromExternalSource">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,origin:%String,fileType:%String,destination:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK  
  
  if (fileType = "CLS") {      
    $$$QuitOnError(##class(%Compiler.UDL.TextServices).SetTextFromFile($namespace, itemName, origin))
  } elseif ##class(Port.Util).IsRoutine(itemName) {                
    if ##class(Port.Util).ExtractType(origin) = "DFI" {
      quit ##class(%DeepSee.UserLibrary.Utils).%Import(origin,1,0)
    }
    
    set routine = ""
    set fs = ##class(%FileCharacterStream).%New()
    set fs.Filename = origin    
    
    if ##class(%RoutineMgr).Exists(itemName) {      
      set routine = ##class(%RoutineMgr).%OpenId(itemName)           
    } else {
      set routine = ##class(%RoutineMgr).%New(itemName)
    }
        
    set code = routine.Code
    do code.Clear()
    $$$QuitOnError(code.CopyFrom(fs))    
    $$$QuitOnError(code.Save())
    $$$QuitOnError(routine.%Save())
  } else {
    set destinationPath = ##class(%File).GetDirectory(destination)
    $$$QuitOnError(##class(Port.Util).CreateMissingPath(destinationPath))    
    set isCopied = ##class(%File).CopyFile(origin, destination, 1)
    if isCopied = 0 {
      set sc = $$$PERROR($$$UnableToCopySource, origin, destinationPath)
    }
  }
  return sc
]]></Implementation>
</Method>

<Method name="GetFileExtension">
<Internal>1</Internal>
<FormalSpec>path:%String,isWebPath:%Boolean</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  if $piece(path, ..Slash, *)?1"."3A return ""
  if isWebPath || (..GetSourceExtension() = "") {
    set sliceSize = 0
  } else {
    set sliceSize = 1
  }
  // -1 to ignore last piece (.txt) when not inside web path or when source extension is not provided.
  return "."_$zconvert($piece(path, ".", *-sliceSize), "U")
]]></Implementation>
</Method>

<Method name="SynchronizeProject">
<Internal>1</Internal>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set (sc, scc) = $$$OK
  set itemName = ""
    
  #dim item As %Studio.Project
  
  // We must check and remove all invalid items if the user desires to import everything
  // from the repository.
  if ..IsBatch $$$QuitOnError(..Project.Check())
  
  // Now that the project is clear, we add the new items.
  for {
    set itemName = $order(i%ItemsList(itemName), 1, type)    
    quit:itemName=""    
    
    set pSC = ..Project.AddItem(itemName)
    
    if ($$$ISERR(pSC) && $$$GETERRORCODE(pSC)) = $$$ProjectIncludesPackage {
      set package = itemName
      for i=1:1:$length(package, ".") {
        set packagePart = $piece(package, 1, *-i)
        set exists = ##class(Port.Util).ExistsInProject(..ProjectName, packagePart_".PKG")
        if exists {
          set sc = $$$ADDSC(sc, ..Project.RemoveItem(package))
          set sc = $$$ADDSC(sc, ..Project.AddItem(itemName))
        } 
      }
    }
  }
  set ssc = ..Project.%Save()
  set scc = $$$EMBEDSC(scc, sc)
  return scc
]]></Implementation>
</Method>

<Method name="ResetLists">
<Implementation><![CDATA[
  
  kill i%ImportList, i%ItemsList
  set (i%ImportList, i%ItemsList) = 0
]]></Implementation>
</Method>

<Method name="AssertValidExtension">
<Final>1</Final>
<Internal>1</Internal>
<FormalSpec>origin:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sourceFileExtension = "."_$$$ucase($piece(origin, ".", *))
  
  if $listfind($$$RoutineExtensions, sourceFileExtension) || (sourceFileExtension = ".CLS") {
    set sourceFileExtension = ""
  }  
  
  if (sourceFileExtension '= $$$ucase(..GetSourceExtension())) {   
    set fileName = ##class(%File).GetFilename(origin)
    set formattedMsg = $select(
      ..SourceExtension = "" : $$$FormatMsg("Port Log Messages", $$$KeepCacheExtension), 
      1: $$$FormatMsg("Port Log Messages", $$$OvewriteWithExtension, ..SourceExtension)
    )
    return $$$PERROR($$$UnableToDescribeItem, fileName, formattedMsg)
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Manager">
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64306,34528.811674</TimeCreated>

<Method name="AssertUtilityCreation">
<ClassMethod>1</ClassMethod>
<FormalSpec>type:%String,path:%String,logLevel:%String,sourceExtension:%String,*sc:%Status</FormalSpec>
<Private>1</Private>
<ReturnType>Port.Project.Base</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set utility = ""  
  set utilityTypes("E") = "Port.Project.Exporter"
  set utilityTypes("I") = "Port.Project.Importer"
  set utilityTypes("X") = "Port.Project.XMLExporter"
  try {
    set utility = $classmethod(utilityTypes(type), "%New", path, logLevel, sourceExtension)
    quit
  } catch ex {
    set sc = ex.AsStatus()
  }
  return utility
]]></Implementation>
</Method>

<Method name="Export">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String,logLevel:%Integer=2,force:%Boolean=0,ignoredPaths:%ListOfDataTypes="",sourceExtension:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set exporter = ..AssertUtilityCreation("E", outputPath, logLevel, sourceExtension, .sc)
  $$$QuitOnError(sc)
  set exporter.Overwrite = force    
  $$$QuitOnError(exporter.Ignore(ignoredPaths))
  $$$QuitOnError(exporter.Export())
  set projectName = exporter.GetProjectName()
  if exporter.AffectedCount > 0 {
    $$$QuitOnError(##class(Port.SourceControl.Log).LogChange(projectName, projectName_".PRJ"))
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="ExportToXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String,logLevel:%Integer=2,justProject:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set exporter = ..AssertUtilityCreation("X", outputPath, logLevel, "", .sc)
  $$$QuitOnError(sc)  
  return exporter.ExportToXML(justProject)
]]></Implementation>
</Method>

<Method name="Import">
<ClassMethod>1</ClassMethod>
<FormalSpec>inputPath:%String,logLevel:%Boolean=2,skipBackup:%Boolean=0,overwrite:%Boolean=0,ignoredPaths:%ListOfDataTypes="",sourceExtension:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set importer = ..AssertUtilityCreation("I", inputPath, logLevel, sourceExtension, .sc)
  $$$QuitOnError(sc)
  $$$QuitOnError(importer.Ignore(ignoredPaths))
  
  set importer.SkipBackup = skipBackup
  set importer.IsBatch = 1
  set importer.Overwrite = overwrite   
  set projectName = importer.GetProjectName()
  
  $$$QuitOnError(importer.Import())
  
  if importer.AffectedCount > 0 {
    $$$QuitOnError(##class(Port.SourceControl.Log).LogChange(projectName, projectName_".PRJ"))
  }
  return sc
]]></Implementation>
</Method>

<Method name="ImportPartial">
<ClassMethod>1</ClassMethod>
<FormalSpec>basePath:%String,target,logLevel:%Boolean=2,skipBackup:%Boolean=0,overwrite:%Boolean=0,ignoredPaths:%ListOfDataTypes="",sourceExtension:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set importer = ..AssertUtilityCreation("I", basePath, logLevel, sourceExtension, .sc)  
  $$$QuitOnError(sc)
  $$$QuitOnError(importer.Ignore(ignoredPaths))
  
  set importer.LogLevel = logLevel
  set importer.SkipBackup = skipBackup
  set importer.Overwrite = 1
     
  $$$QuitOnError(importer.ImportPartial(target, .importedList))
  
  do ..LogFromImportList(importer.GetProjectName(), .importedList)
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveInvalidItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String=^||Port.Project</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set project = ##class(%Studio.Project).%OpenId(projectName)
  $$$QuitOnError(project.Check())
  $$$QuitOnError(project.%Save()) 
  return $$$OK
]]></Implementation>
</Method>

<Method name="RemoveItemsByType">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,type:%String,*items:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set project = ##class(%Studio.Project).%OpenId(projectName)
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(projectName)
  
  while r.%Next() {
    set itemType = r.%Get("Type")
    set name = r.%Get("Name")
    if itemType = type {
      set items(name) = ""     
      set sc = project.RemoveItem(name, itemType)
      if $$$ISERR(sc) quit
    }
  }
  $$$QuitOnError(project.%Save())
  return sc
]]></Implementation>
</Method>

<Method name="ExportTestSuiteToXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>outputPath:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set testPath = ##class(Port.Configuration).GetTestPath()
  set exporter = ..AssertUtilityCreation("X", .outputPath, 2, "", .sc)
  $$$QuitOnError(sc)
  return exporter.ExportTests(outputPath_"/"_testPath)
]]></Implementation>
</Method>

<Method name="LogFromImportList">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[projectName:%String,&importList:%String]]></FormalSpec>
<Private>1</Private>
<Implementation><![CDATA[
  if 'importList quit
  
  for i=1:1:10 {
    do LoopThroughType(projectName, importList, i)
  }  
  
LoopThroughType(projectName, importedList, group)
  set itemName = "" 
  
  for {
    set itemName = $order(importList(group, $listget($$$ImportTypes, group), itemName))
    quit:itemName=""
    
    if group = 2 set itemName = itemName_".CLS"   
    do ##class(Port.SourceControl.Log).LogChange(projectName, itemName)
  }
  return 1
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.Synchronizer">
<IncludeCode>portutils</IncludeCode>
<Super>%RegisteredObject</Super>
<TimeCreated>64471,51323.955849</TimeCreated>

<Property name="ExtraneousEntries">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="Whitelist">
<Type>%String</Type>
<Collection>array</Collection>
<Private>1</Private>
</Property>

<Property name="Tool">
<Type>Port.Project.Base</Type>
<Private>1</Private>
</Property>

<Property name="TypePaths">
<Type>%List</Type>
<Private>1</Private>
</Property>

<Property name="Simulated">
<Type>%Boolean</Type>
<InitialExpression>0</InitialExpression>
</Property>

<Method name="%OnNew">
<FormalSpec>tool:Port.Project.Base,simulated:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Tool = tool
  set ..Simulated = simulated
  set ..TypePaths = $lb(tool.BasePath)
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddToWhitelist">
<Internal>1</Internal>
<FormalSpec>itemName:%String,sourceLocation:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set sc = $$$OK
  set type = ##class(Port.Util).ResolveItemExtension(itemName)
  set typePath = ..Tool.GetTypePath(type)
  set slash = $$$Slash(typePath)  
  
  if sourceLocation = "" {
    set workspacePath = $piece(typePath, slash, 1, *-1)
    set sourceLocation = ##class(Port.Util).MountItemSourcePath(itemName, workspacePath)
  }
  
  if $extract(typePath) = "/" {
    set typePath = $extract(typePath, 2, *)
  }
    
  set absoluteBasePath = ##class(%File).NormalizeFilename(typePath, slash)
  set dirLength = $length(sourceLocation, slash)
  set dirLengthLimit = dirLength - (dirLength - $length(absoluteBasePath, slash))
  
  // Slices the path for every iteration. Ex: /a/b/c -> /a/b -> /a
  for i=dirLength:-1:dirLengthLimit+1 {
    set dir = $piece(sourceLocation, slash, 1, i)
    
    if ..Whitelist.IsDefined(dir) return $$$OK    
    set sc = ..Whitelist.SetAt(itemName, dir)    
    if $$$ISERR(sc) quit
  }
  return sc
]]></Implementation>
</Method>

<Method name="Purge">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set sc = $$$OK
  set s = ##class(%SQL.Statement).%New()  
  
  $$$QuitOnError(s.%PrepareClassQuery("%File", "FileSet"))
  
  set removedDirectories = ""
  set lastParent = ""
  set parentDirectory = ""  
  
  write ..Tool.LogLine($$$CheckingExtraneousItems, 1)
  
  for i=1:1:$listlength(i%TypePaths) {
    set pathToSearch = $listget(i%TypePaths, i)
    set sc = ..Scan(s, pathToSearch)
    if $$$ISERR(sc) return sc
  }
  
  set length = $listlength(i%ExtraneousEntries)
  if length > 0 write ..Tool.LogLine($$$TotalExtraneousItems, 1, length)
  else  write ..Tool.LogLine($$$NoExtraneousItems, 1)
  
  for i=1:1:length {
    set possiblyDeleted = 0
    set extraneousItem = $listget(i%ExtraneousEntries, i)
    set path = $listget(extraneousItem, 1)
    set slash = $$$Slash(path)
    set type = $listget(extraneousItem, 2)
    if parentDirectory '= "" && (path [ parentDirectory) set possiblyDeleted = 1
    if type = "F" && ##class(%File).Exists(path) {
      set fileName = ##class(%File).GetFilename(path)
      set lastNode = ##class(%File).GetDirectoryPiece(parentDirectory, $length(parentDirectory, slash))
      set fileName = $piece(fileName, ".", 1)           
      if fileName = lastNode set possiblyDeleted = 0 
      if possiblyDeleted = 1 continue
      write ..Tool.LogLine($$$RemovingFile, 2, path)
      if ..Simulated = 0 do ##class(%File).Delete(path)
    } elseif type = "D" {
      if parentDirectory = "" || (path '[ parentDirectory) {
        set lastParent = parentDirectory
        set parentDirectory = $replace(path, ##class(%File).GetDirectoryPiece(path, $length(path, slash))_slash, "")
        if lastParent = "" set lastParent = parentDirectory
      }
      if possiblyDeleted = 1 continue
      write ..Tool.LogLine($$$RemovingDirectory, 2, path)
      if ..Simulated = 0 do ##class(%File).RemoveDirectoryTree(path)
    }
  } 
  if length > 0 {
    write ..Tool.LogLine($$$TotalExtraneousItemsRemoved, 1, length)
  }
  return sc
]]></Implementation>
</Method>

<Method name="Scan">
<FormalSpec>statement:%SQL.Statement,path:%String,filesCount:%Integer=0</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set dir = $$$NFN(path)
  set dirType = ##class(Port.Util).ExtractType(path, ..Tool.BasePath)
  // Need to convert from Port format to CSP legacy format.
  if dirType = "WEB" set dirType = "CSP"
  
  set slash = $$$Slash(path)
  set row = statement.%Execute(dir)
  set sc = $$$OK     
         
  while row.%Next(.sc) {
    if $$$ISERR(sc) quit
    set type = row.%Get("Type")    
    set fullPath = row.%Get("Name")
    
    if ..Tool.IsIgnored(fullPath) continue
            
    if type = "D" {
      set filesCount = 0      
      set sc = ..Scan(statement, fullPath, .filesCount)
      if $$$ISERR(sc) return sc
    } else {
      set filesCount =  filesCount + 1
    }       
     
    if 'filesCount && $lf($$$ImportTypes, dirType) || ($lf($$$ImportTypes, dirType) && '..Whitelist.IsDefined(fullPath) && '$listfind(i%ExtraneousEntries, fullPath)) {
      set $list(i%ExtraneousEntries, $listlength(i%ExtraneousEntries)+1) = $listbuild(fullPath, type)            
    }
  }
  return sc
]]></Implementation>
</Method>

<Method name="Reset">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set i%ExtraneousEntries = ""
  return ..Whitelist.Clear()
]]></Implementation>
</Method>
</Class>


<Class name="Port.Project.XMLExporter">
<Super>Port.Project.Base</Super>
<TimeCreated>64306,34528.900364</TimeCreated>

<Method name="ExportToXML">
<FormalSpec>justProject:%Boolean=0,qspec:%String="/diffexport=1/nodisplay",charset:%String="UTF8",*errorlog:%Status=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set developmentXML = ##class(%File).NormalizeFilename(..BasePath_"/"_..ProjectName_".xml")
  set productionXML = ##class(%File).NormalizeFilename(..BasePath_"/"_..ProjectName_"-prod.xml")
  write ..LogLine($$$ExportingXML, 0, ..ProjectName)
  $$$QuitOnError(..Project.Export(developmentXML, qspec, justProject, errorlog, charset))
  write ..LogLine($$$XMLExportedTo, 0, ..ProjectName, developmentXML)  
  
  do RemoveTestClasses(.items)  
  
  if $order(items("")) '= "" {  
    $$$QuitOnError($System.OBJ.Export(.items, productionXML, qspec, errorlog, charset))
    write ..LogLine($$$XMLExportedTo, 0, ..ProjectName, productionXML)
  }
    
  return $$$OK    
  
RemoveTestClasses(items="")
  set sc = $$$OK 
  set testPrefix = ##class(Port.Configuration).GetTestClassPrefix()
  if testPrefix '= "" {
    for i=1:1:..Project.Items.Count() {  
      set item  = ..Project.Items.GetAt(i) 
      if $isobject(item) && (item.Type '= "PRJ") && '($extract(item.Name, 1, $length(testPrefix)) = testPrefix && (item.Type = "CLS")) {
        set name = item.Name
        set type = item.Type
        do ##class(%Studio.Project).NormalizeName(.name, .type)        
        if type = "CLS" || (type = "PKG") set name = name_"."_type        
        set items(name) = "" 
      }
    }
  }
  quit
]]></Implementation>
</Method>

<Method name="ExportTests">
<FormalSpec><![CDATA[path:%String,qspec:%String="/diffexport=1/nodisplay",&tests:%String="",&errors=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set sc = $$$OK
  set exported = 0
  
  set absoluteBasePath = ##class(%File).NormalizeFilename(path)
  $$$QuitOnError(##class(Port.Util).CreateMissingPath(absoluteBasePath))
  
  set s = ##class(%SQL.Statement).%New()
  $$$QuitOnError(s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList"))
  set r = s.%Execute(..Project.Name)
  while r.%Next(.sc) {
    if $$$ISERR(sc) quit
    set type = r.%Get("Type")
    if type = "CLS" {     
      set class = r.%Get("Name")      
      if 'exported set exported = ..ExportTest(absoluteBasePath, class, .esc, qspec)
      else  do ..ExportTest(absoluteBasePath, class, .esc)          
      set sc = $$$ADDSC(sc, esc)
    }
  } 
  if 'exported {
    set sc = $$$PERROR($$$NoTestSuitesWereFound)
  }
  return sc
]]></Implementation>
</Method>

<Method name="ExportTest">
<FormalSpec>absoluteBasePath:%String,className:%String,sc:%Status=$$$OK,qspec="/diffexport=1/nodisplay"</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set sc = $$$OK
  set exported  = 0
  
  if '##class(Port.UnitTest.Util).IsUnitTestClass(className) return exported  
  
  set test = ##class(Port.UnitTest.Util).ResolveTestLocation(absoluteBasePath, className)
  
  if $listvalid(test) && (test '= "") {
    set className = $listget(test, 1)
    set classPath = $listget(test, 2)
    write ..Log($$$ExportingTestClassToXML, 0, $replace(className, ".CLS", ""))
    set cSC = $System.OBJ.Export(className, classPath,qspec,, "UTF-8")
    set sc = $$$ADDSC(sc, cSC)
    if $$$ISOK(cSC) write ..LogLine($$$Done, 0)
    else  write ..LogLine($$$Failed, 0)
    set exported = 1
  }
  return exported
]]></Implementation>
</Method>

<Method name="T">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set xml = ##class(Port.Project.XMLExporter).%New("/CacheProjects/DEV/frontier")
  do xml.ExportToXML()
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.ExtendedHooks">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64496,37005.318621</TimeCreated>

<Method name="Call">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>sourceControl:%Studio.Extension.Base,hookName:%String="",parameters...:%String</FormalSpec>
<ProcedureBlock>0</ProcedureBlock>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  new sc, content, implementer, alreadyRedirected, 
      isNewLineTerminator, currentMnemonic, 
      childSC, expectingContent, firstLine, s
  
  set sc = $$$OK
  set s = ""
  set childSC = $$$OK
  set implementer = ##class(Port.Configuration).GetExtendedHooksImplementer() 
  set alreadyRedirected = ##class(%Device).ReDirectIO()
  set expectingContent = 0
  set firstLine = ""
  
  if '##class(%Dictionary.CompiledMethod).%ExistsId(implementer_"||"_hookName) return sc 
  set content = ##class(%Stream.GlobalBinary).%New() 
  
  if implementer '= "" { 
    write !, "[Port] "_$$$FormatMsg("Port Log Messages", $$$RunningCustomHook, hookName, implementer)
    
    try {
      set currentMnemonic = "^"_##class(%Device).GetMnemonicRoutine()
      use $io::("^"_$zname)
      do ##class(%Device).ReDirectIO(1)
      set sc = $classmethod(implementer, hookName, sourceControl, parameters...)
    } catch ex {
      set content = "" 
      set sc = ex.AsStatus() 
    }
  }
  
  if alreadyRedirected { 
    do ##class(%Device).ReDirectIO(1) 
    use $io::(currentMnemonic) 
  }
  
  if $isobject(content) {  
    do content.OutputToDevice()    
  }
  
  write !       
  
  if $$$ISOK(sc) {    
    write "[Port] "_$$$FormatMsg("Port Log Messages", $$$HookReturnedOK, hookName)
  } else {
    set errorText = $System.Status.GetOneStatusText(sc)
    write "[Port] "_$$$FormatMsg("Port Log Messages", $$$HookReturnedError, hookName, errorText)
    set childSC = sc
    set sc = $$$PERROR($$$FailedWhileRunningExtendedHook, hookName)    
    set sc = $$$EMBEDSC(sc, childSC)  
  }
  write !   
  return sc 
  
rchr(c)      
  quit
rstr(sz,to)  
  quit
wchr(s)      
  do output($char(s))  
  quit 
wff()        
  do output($char(12))  
  quit
wnl()
  if firstLine = 0 set firstLine = 1
  else  set firstLine = -1
  do output($char(13,10))
  quit
wstr(s)
  do output(s) 
  quit
wtab(s)      
  do output($char(9)) 
  quit
output(s)
  // Skips writing the first !, we leave it to our write.
  if firstLine = 1 quit
  // Remaining writes ! are always a standalone buffer so we can check it's equality.
  if s = $c(13,10) {
    // However we can only write if the the next buffer has indeed some content.
    // So we defer it to the next call where we can actually assert it.    
    set expectingContent = 1
    // This catches writes with embedded CRLF (like the compiler ones).    
  } elseif $extract(s, 1, 2) = $c(13,10) {
    set expectingContent = 1
    do output($replace(s, $c(13,10), ""))
    set expectingContent = 0 
    quit
  } elseif $length(s) > 0 {
    // After deferring it, we can finally write a CRLF and the content, as long as it's not empty.
    if expectingContent = 1 { 
      set expectingContent = 0      
      do content.WriteLine("")
      do content.Write($$$FormatText("[Port] %1: ", hookName)) 
    }
    // Writes without ! must be written on the same line.     
    do content.Write(s)
  }
   
  quit
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Hooks">
<IncludeCode>portutils</IncludeCode>
<Super>%Studio.SourceControl.Base</Super>
<TimeCreated>64306,34529.285329</TimeCreated>

<XData name="Menu">
<Data><![CDATA[
<MenuBase>
<Menu Name="%SourceMenu" Type="0">
<MenuItem Name="%MLExport"/>
<MenuItem Name="%MLExportToXML"/>
<MenuItem Name="%MLExportTests"/> 
<MenuItem Separator="1" />
<MenuItem Name="%MLRemoveClasses"/>
<MenuItem Name="%MLRemoveFiles"/>
<MenuItem Name="%MLRemoveRoutines"/>
<MenuItem Separator="1" />
<MenuItem Name="%MLScanAndFix"/>
<MenuItem Separator="1" />
<MenuItem Name="%MLRunTests"/> 
<MenuItem Separator="1" />
<MenuItem Name="%MLImport"/>
<MenuItem Separator="1" />
<MenuItem Name="%MLForceExport"/>
<MenuItem Name="%MLForceImport"/>
</Menu>
<Menu Name="%SourceContext" Type="1">
<MenuItem Name="%CMLExportActive" />
<MenuItem Name="%CMLImportActive" />
<MenuItem Separator="1" />
<MenuItem Name="%CMLRunActiveTest"/>
</Menu>
</MenuBase>
]]></Data>
</XData>

<Method name="OnAfterSave">
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim exporter As Port.Project.Exporter
  if $get(%importingFromXML, 0) return $$$OK 
  
  set sc = $$$OK
  set projectName = $get(^||Port.Project)
  if projectName [ "Default" || (projectName = "") return sc  
  
  if projectName '= "" { 
    set exportPath = ##class(Port.Configuration).GetWorkspace()    
    set type = ##class(Port.Util).ResolveItemExtension(InternalName)       
    
    if '##class(%File).DirectoryExists($$$NFN(exportPath)) {
      set logLevel = ##class(Port.Configuration).GetLogLevel()
      set sourceExtension = ##class(Port.Configuration).GetSourceExtension()
     
      write "[Port] "_$$$FormatMsg("Port Log Messages", $$$NewWorkspaceDetected, projectName), !
     
      $$$QuitOnError(##class(Port.Project.Manager).Export(exportPath, logLevel, 1,, sourceExtension))
      // Called with do, because we don't want to display errors from it.
      do ##class(Port.Project.Manager).ExportTestSuiteToXML(exportPath) 
      
      return $$$OK
    }
    
    if type '= "PRJ" {
      set sourceExtension = ##class(Port.Configuration).GetSourceExtension()
      set exporter = ##class(Port.Project.Exporter).%New(exportPath, 2)
      set shouldExportAsXML = ##class(Port.Configuration).IsAutoExportXMLEnabled()      
      set ubiquitousList = ##class(Port.Util).ListConflicts(projectName, InternalName)
            
      set exporter.SourceExtension = sourceExtension
      
      if '##class(Port.Util).ExistsInProject(projectName, InternalName) {
        return $$$OK
      }
      
      if ubiquitousList '= "" {
        write !, "[Port] "_$$$FormatMsg("Port Log Messages", $$$ConflictingItemDetected, InternalName, $lfs(ubiquitousList))
        write !, "[Port] "_$$$FormatMsg("Port Log Messages", $$$ConflictingItemDetected2)
      }
      
      if type = "CLS" {
        set sc = exporter.ExportClass(InternalName)
        if ##class(Port.UnitTest.Util).AssertTestableClass(InternalName, .testableClass) {          
          set testPath = ##class(Port.Configuration).GetTestPath()
          set xmlExporter = ##class(Port.Project.XMLExporter).%New(exportPath, 2)
          do xmlExporter.ExportTest($$$NFN(exportPath_"/"_testPath), testableClass, .ssc)          
          set sc = $$$ADDSC(sc, ssc)
        }
      } elseif ##class(Port.Util).IsRoutine(InternalName) {
        write InternalName, !
        set sc = exporter.ExportRoutine(InternalName)
      } elseif type = "PKG" {     
        set sc = exporter.ExportPackage(InternalName)     
      } elseif type '= "" {
        set sc = exporter.ExportWebFile(InternalName)     
      }   
      
      $$$QuitOnError(##class(Log).LogChange(projectName, InternalName))
      if shouldExportAsXML $$$QuitOnError(##class(Port.Project.Manager).ExportToXML(exportPath, 2))      
    }  
  }
  if '##class(Port.Configuration).HasCustomWorkspace(projectName) {
    do ##class(Port.Configuration).SetCustomWorkspace(projectName)
  }
  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterSave", InternalName)) 
  return sc
]]></Implementation>
</Method>

<Method name="OnBeforeSave">
<FormalSpec>InternalName:%String,Location:%String="",Object:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $get(%importingFromXML, 0) return $$$OK
  set projectName = $get(^||Port.Project)  
  set ext = ##class(Port.Util).ResolveItemExtension(InternalName)
  set isProject = (ext = "PRJ")  
  
  if isProject {
    set projectName = $replace(InternalName, ".PRJ", "")
    set ^||Port.Project = projectName  
    if projectName [ "Default" {
      write "[Port] "_$$$FormatMsg("Port Log Messages", $$$CannotUseDefault), !
      write "[Port] "_$$$FormatMsg("Port Log Messages", $$$CannotUseDefault2), !
      return $$$ERROR($$$CanNotExportDefaultProject, projectName)
    }
  } else {
    set projectsOwningItem = $lts(##class(Port.Util).ListConflicts(projectName, InternalName), $char(10))
    if projectsOwningItem '= "" {
      return $$$PERROR($$$CannotSaveConflictingItems, InternalName, $char(10, 10)_projectsOwningItem, projectName)
    }
  }    

  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeSave", InternalName, Location, Object))
  return $$$OK
]]></Implementation>
</Method>

<Method name="UserAction">
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,SelectedText:%String,&Action:%String,&Target:%String,&Msg:%String,&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set name = $piece(Name, ",", 2)
  set isContextual = ($piece(Name, ",", 1) = "%SourceContext")
  // We must know if the user is importing from a XML and prevent it from realizing certain tasks automatically.
  set %importingFromXML = (Name = 6)
  
  if $data(^||Port.Project) {
    set projectName = ^||Port.Project
    if projectName [ "Default" return $$$OK
    set fullPath = ##class(Port.Util).GetItemSourcePathFromWorkspace(InternalName)
    set projectPath = ##class(Port.Configuration).GetWorkspace()
    set testPath = ##class(Port.Configuration).GetTestPath()
    set logLevel = ##class(Port.Configuration).GetLogLevel()
    set shouldExportAsXML = ##class(Port.Configuration).IsAutoExportXMLEnabled()
    set sourceExtension = ##class(Port.Configuration).GetSourceExtension()
    set ignoredPaths = ##class(Port.Util).GetIgnoredPaths(projectPath)
    
    if name = "%MLExport" {
      set shouldOverwrite = '##class(Port.Configuration).IsSameSourceExtension()
      if shouldOverwrite do ##class(Port.Configuration).TrackActiveExtension()      
      $$$QuitOnError(##class(Port.Project.Manager).Export(projectPath, logLevel, shouldOverwrite, ignoredPaths, sourceExtension))
      if shouldExportAsXML $$$QuitOnError(##class(Port.Project.Manager).ExportToXML(projectPath))      
      return $$$OK
    }
    if name = "%MLExportToXML" {
      return ##class(Port.Project.Manager).ExportToXML(projectPath)
    }
    if name = "%MLExportTests" {
      return ##class(Port.Project.Manager).ExportTestSuiteToXML(projectPath)
    }
    if name = "%MLRunTests" && (projectPath '= "") {      
      $$$QuitOnError(##class(Port.UnitTest.Manager).RunTest(testPath, "/recursive/run/noload/nodelete"))
    }       
    if name = "%MLImport" {
      $$$QuitOnError(##class(Port.Project.Manager).Import(projectPath, logLevel, 0, 0,,sourceExtension))
    }
    if name = "%MLRemoveClasses" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsByType(projectName, "CLS"))
      return ##class(Log).Synchronize()
    }
    if name = "%MLRemoveFiles" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsByType(projectName, "CSP"))
      return ##class(Log).Synchronize()
    }
    if name = "%MLRemoveRoutines" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveItemsByType(projectName, "MAC"))
      return ##class(Log).Synchronize()
    }
    if name = "%MLScanAndFix" {
      $$$QuitOnError(##class(Port.Project.Manager).RemoveInvalidItems(projectName))
      return ##class(Log).Synchronize()     
    }
    
    if name = "%CMLExportActive" {
      if $$$ucase(InternalName) '= ($$$ucase(projectName_".PRJ")) {
        set exporter = ##class(Port.Project.Exporter).%New(projectPath)
        set exporter.Overwrite = 1
        set exporter.SourceExtension = sourceExtension
        set internalName = InternalName
        if $extract(InternalName, 1) = "/" {
          set internalName = $extract(InternalName, 2, *)
        }
        $$$QuitOnError(exporter.ExportItem(internalName))
        $$$QuitOnError(##class(Log).LogChange(projectName, internalName))
        if shouldExportAsXML $$$QuitOnError(##class(Port.Project.Manager).ExportToXML(projectPath))
      } else {
        set ignoredPaths = ##class(Port.Util).GetIgnoredPaths(projectPath)
        return ##class(Port.Project.Manager).Export(projectPath, logLevel, 1)
      }
    }
    
    if name = "%CMLImportActive" {
      if $$$ucase(InternalName) = ($$$ucase(projectName_".PRJ")) {
        return ##class(Port.Project.Manager).Import(projectPath, logLevel, 0, 1, ignoredPaths, sourceExtension)
      } else {
        return $$$OK 
      }
    }
    
    if name = "%CMLRunActiveTest" {
      set testable = ##class(Port.UnitTest.Util).AssertTestableClass(InternalName, .testableClass)
      if testable {
        $$$QuitOnError(##class(Port.UnitTest.Manager).RunTest(##class(Port.UnitTest.Util).GetTestPathForClass(testableClass), "/norecursive/run/noload/nodelete"))
      }
    }
    
    if name = "%MLForceExport" {
      set shouldOverwrite = '##class(Port.Configuration).IsSameSourceExtension()
      if shouldOverwrite do ##class(Port.Configuration).TrackActiveExtension()
      $$$QuitOnError(##class(Port.Project.Manager).Export(projectPath, logLevel, 1, ignoredPaths, sourceExtension))
      if shouldExportAsXML $$$QuitOnError(##class(Port.Project.Manager).ExportToXML(projectPath))
      if '##class(Port.Configuration).HasCustomWorkspace(projectName) { 
        do ##class(Port.Configuration).SetCustomWorkspace(projectName)
      }
    }
    
    if name = "%MLForceImport" {
      return ##class(Port.Project.Manager).Import(projectPath, logLevel, 0, 1, ignoredPaths, sourceExtension)
    }    
  }
  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "UserAction",  Type, Name, InternalName, SelectedText, .Action, .Target, .Msg, .Reload))
  return $$$OK
]]></Implementation>
</Method>

<Method name="AfterUserAction">
<FormalSpec><![CDATA[Type:%Integer,Name:%String,InternalName:%String,Answer:%Integer,Msg:%String="",&Reload:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "AfterUserAction", Type, Name, InternalName, Answer, .Msg, .Reload)
]]></Implementation>
</Method>

<Method name="OnMenuItem">
<FormalSpec><![CDATA[MenuName:%String,InternalName:%String,SelectedText:%String,&Enabled:%Boolean,&DisplayName:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set menu=$piece(MenuName,","),name=$piece(MenuName,",",2)
  If menu'="%SourceMenu",menu'="%SourceContext" Quit $$$OK
  set isContextual = (menu = "%SourceContext")
  set domain = "Port Menu Labels"
  
  if 'isContextual {
    set code = $case(name, 
      "%MLExport": $$$MLExport,
      "%MLExportToXML": $$$MLExportToXML,
      "%MLExportTests": $$$MLExportTests,
      "%MLRemoveClasses": $$$MLRemoveClasses,
      "%MLRemoveFiles": $$$MLRemoveFiles,
      "%MLRemoveRoutines": $$$MLRemoveRoutines,
      "%MLScanAndFix": $$$MLScanAndFix,
      "%MLRunTests": $$$MLRunTests,
      "%MLImport": $$$MLImport,
      "%MLForceExport": $$$MLForceExport, 
      "%MLForceImport": $$$MLForceImport,
      : ""
     )
  } else {
    set domain = "Port Context Menu Labels"
    set code = $case(name, 
      "%CMLExportActive": $$$CMLExportActive,
      "%CMLImportActive": $$$CMLImportActive,
      "%CMLRunActiveTest": $$$CMLRunActiveTest,
      : ""
    )          
  }
  
  if code '= "" {
    // We can only change the text if we find it, otherwise we leave the Studio decide what to show.
    set DisplayName = $$$FormatMsg(domain, code)
  }
  
  if name = "%CMLRunActiveTest" {
    set Enabled = 
      ##class(Port.Util).ExistsInProject(^||Port.Project, InternalName) &&
      ##class(Port.UnitTest.Util).AssertTestableClass(InternalName)
  } 
  
  set isProjectOpened = ($get(^||Port.Project, "Default") '[ "Default")
  if 'isProjectOpened {
    set Enabled = 0
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterCompile">
<Description>
Called after the compile of the item is done.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $get(%importingFromXML, 0) return $$$OK
  set projectName = $get(^||Port.Project)
  set sc = $$$OK
  
  if projectName '= "" && (projectName '[ "Default") {
    set projectPath = ##class(Port.Configuration).GetWorkspace()
    set type = ##class(Port.Util).ResolveItemExtension(InternalName)
    set xmlExporter = ##class(Port.Project.XMLExporter).%New(projectPath)
    
    if type = "CLS" {     
      set testPath = ##class(Port.Configuration).GetTestPath()      
      set shouldRunTest = (
        ##class(Port.Configuration).IsTestOnDemandEnabled() &&
        ##class(Port.UnitTest.Util).AssertTestableClass(InternalName, .testableClass) &&
        ##class(%File).DirectoryExists(projectPath_"/"_testPath)        
      )
      if shouldRunTest {
       $$$QuitOnError(xmlExporter.ExportTest(projectPath, testableClass))
       $$$QuitOnError(##class(Port.UnitTest.Manager).RunTest(##class(Port.UnitTest.Util).GetTestPathForClass(testableClass), "/norecursive/run/noload/nodelete"))
      } 
    }
  }
  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterCompile",  InternalName))
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeDelete">
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  // This is used to prevent orphan workspace entries.
  if (InternalName?1".PRJ") {
    set projectName = $piece(InternalName, ".", 1, *-1)
    do ##class(Port.Configuration).RemoveCustomWorkspace(projectName)
  }
  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeDelete",  InternalName))
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeLoad">
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set isProject = (##class(Port.Util).ResolveItemExtension(InternalName) = "PRJ")
  
  // Port normally uses its own project global to track the opened project and stop %Studio.Project methods from disrupting the source control instance.
  if isProject {
    set ^||Port.Project = $piece(InternalName, ".", 1, *-1)  
  } elseif '$data(^||Port.Project) {
    set ^||Port.Project = $get(^||%Studio.Project)
  }
   
  set projectName = ^||Port.Project
      
  if projectName '= "" && (projectName [ "Default") {
    write "[Port] "_$$$FormatMsg("Port Log Messages", $$$CannotUseDefault), !
    write "[Port] "_$$$FormatMsg("Port Log Messages", $$$CannotUseDefault2), !
  }  
  
  set ubiquitousList = ##class(Port.Util).ListConflicts(projectName, InternalName)
  if ubiquitousList '= "" {
    write !, "[Port] "_$$$FormatMsg("Port Log Messages", $$$ConflictingItemDetected, InternalName, $lts(ubiquitousList, ", "))
    write !, "[Port] "_$$$FormatMsg("Port Log Messages", $$$ConflictingItemDetected2), !
  }
  $$$QuitOnError(##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeLoad",  InternalName))
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterAllClassCompile">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[List:%String,Level:%Integer,&qstruct:%String,Status:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##super(.List, .Level, .qstruct, .Status))
  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterAllClassCompile", .List, Level, .qstruct, Status)
]]></Implementation>
</Method>

<Method name="OnAfterClassCompile">
<FormalSpec><![CDATA[List:%String,Level:%Integer,&qstruct:%String,Status:%Status]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterClassCompile", .List, Level, qstruct, Status)
]]></Implementation>
</Method>

<Method name="OnAfterDelete">
<Description>
Called after an item is deleted.</Description>
<FormalSpec>InternalName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterDelete", InternalName)
]]></Implementation>
</Method>

<Method name="OnAfterLoad">
<FormalSpec>InternalName:%String,Object:%RegisteredObject=$$$NULLOREF</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterLoad", InternalName)
]]></Implementation>
</Method>

<Method name="OnAfterStorage">
<FormalSpec>InternalName:%String,Location:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnAfterStorage", InternalName, Location)
]]></Implementation>
</Method>

<Method name="OnBeforeAllClassCompile">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[List:%String,Level:%Integer,&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(##super(.List, Level, .qstruct))
  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeAllClassCompile", .List, Level, qstruct)
]]></Implementation>
</Method>

<Method name="OnBeforeClassCompile">
<FormalSpec><![CDATA[List:%String,Level:%Integer,&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeClassCompile", .List, Level, qstruct)
]]></Implementation>
</Method>

<Method name="OnBeforeCompile">
<FormalSpec><![CDATA[InternalName:%String,&qstruct:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeCompile", InternalName, qstruct)
]]></Implementation>
</Method>

<Method name="OnBeforeTimestamp">
<FormalSpec>InternalName:%String</FormalSpec>
<Implementation><![CDATA[  return ##class(Port.SourceControl.ExtendedHooks).Call($this, "OnBeforeTimestamp", InternalName)
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.Log">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64306,34529.444198</TimeCreated>

<Method name="LogChange">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName=^||Port.Project,itemName:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ..ExtractItemDescription(itemName, .name, .type)
  set ^Port.SourceControl.Projects(projectName, type, name) = $zdatetime($horolog, 3,,,,,,,,,0) 
  return $$$OK
]]></Implementation>
</Method>

<Method name="ExtractItemDescription">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName,*name="",*type=""</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  set type = $$$ucase($piece(itemName, ".", *))
  set name = $piece(itemName, ".", 1, *-1)
  if '$listfind($$$ImportTypes, type) && (type '= "PRJ") {
    set name = itemName
    set type = "CSP"
  }
]]></Implementation>
</Method>

<Method name="GetLastChange">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,itemName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  do ..ExtractItemDescription(itemName, .name, .type)
  return $get(^Port.SourceControl.Projects(projectName, type, name), 0)
]]></Implementation>
</Method>

<Method name="Synchronize">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #define ProjectExists(%id) ##class(%Studio.Project).%ExistsId(%id)
  #define ItemExists(%id) ##class(%Studio.ProjectItem).%ExistsId(%id)
  
  set sc = $$$OK
  if '$data(^Port.SourceControl.Projects) return sc
  
  set global = "^Port.SourceControl.Projects"
  set q = $query(@global@(""))
  for {
    quit:q=""
    
    set projectName = $qsubscript(q, 1)
    set type = $qsubscript(q, 2)
    set itemName = $qsubscript(q, 3)
    
    if type '= "CLS" && (type '= "PRJ") set itemName = itemName_"."_type
    if type = "CSP" set itemName = $extract(itemName, 2, *)
    set itemId = projectName_"||"_itemName_"||"_type
    if '$$$ProjectExists(projectName) || '$$$ItemExists(itemId) {
      kill @q
    }
    set q = $query(@q, 1)
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="Flush">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  kill ^Port.SourceControl.Projects
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.SourceControl.LogCleaner">
<Super>%SYS.Task.Definition</Super>
<TimeCreated>64306,34529.529651</TimeCreated>

<Method name="StartTask">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set taskName = "Port Log Synchronizer for "_$namespace
  if ##class(%SYS.Task).FindId(taskName) return $$$OK    
  set task = ##class(%SYS.Task).%New()
  set task.TimePeriod = 0
  set task.Description = "Keeps the log synchronized with existing projects and files."
  set task.Name = taskName
  set task.TimePeriodEvery = 1
  set task.DailyFrequency = 1
  set task.DailyFrequencyTime = 0
  set task.DailyStartTime = 28800
  set task.DailyIncrement = 180
  set task.NameSpace = $namespace
  set task.TaskClass = $classname($this)
  return task.%Save()
]]></Implementation>
</Method>

<Method name="RemoveTask">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  #dim task as %SYS.Task
  
  set name = "Port Log Synchronizer for "_$namespace
  set taskId = ##class(%SYS.Task).FindId(name)
  
  if taskId = "" return $$$OK
  $$$QuitOnError(##class(%SYS.Task).Suspend(taskId, 2))
  $$$QuitOnError(##class(%SYS.Task).%DeleteId(taskId))
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnTask">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ##class(Port.SourceControl.Log).Synchronize()
]]></Implementation>
</Method>
</Class>


<Class name="Port.TestUtils.MockProject">
<Super>%RegisteredObject</Super>
<TimeCreated>64239,32011.631107</TimeCreated>

<Parameter name="MOCKNAME">
<Default>Faux</Default>
</Parameter>

<Property name="Project">
<Type>%Studio.Project</Type>
</Property>

<Property name="ItemsList">
<Type>%String</Type>
<MultiDimensional>1</MultiDimensional>
</Property>

<Property name="FixtureDirectory">
<Type>%String</Type>
</Property>

<Method name="%OnNew">
<FormalSpec>fixtureDir:%String,withFauxFiles:%Boolean=0,addToProject:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..FixtureDirectory = fixtureDir
  $$$QuitOnError(..Create(withFauxFiles, addToProject))
  return $$$OK
]]></Implementation>
</Method>

<Method name="%OnClose">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(..Delete())
  return $$$OK
]]></Implementation>
</Method>

<Method name="Delete">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if ##class(%Studio.Project).%ExistsId(..#MOCKNAME) {    
    $$$QuitOnError(##class(%Studio.Project).Delete(..#MOCKNAME))
    $$$QuitOnError(..DisposeFauxItems())
  }  
  return $$$OK
]]></Implementation>
</Method>

<Method name="Create">
<FormalSpec>withFauxFiles:%Boolean=0,addToProject:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  $$$QuitOnError(..Delete())
  set ..Project = ##class(%Studio.Project).%New(..#MOCKNAME)
  set ..Project.Name = ..#MOCKNAME
  if withFauxFiles  $$$QuitOnError(..CreateFauxItems())
  if addToProject   $$$QuitOnError(..AddItemsToProject())
  set sc = ..Project.%Save()
  $$$QuitOnError(sc)
  return $$$OK
]]></Implementation>
</Method>

<Method name="CreateFauxItems">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  #define TAB $char(9)
  #define GetAbsolutePath(%relative) ##class(%File).Normalize($System.Util.InstallDirectory, %relative)    
  set sc = $$$OK
  
  set fauxItems = 13
  set fauxItems(1)  = "Faux.Class.cls"
  set fauxItems(2)  = "fauxjs.js"
  set fauxItems(3)  = "fauxcss.css"
  set fauxItems(4)  = "fauxinc.inc"
  set fauxItems(5)  = "fauxmac.mac"
  set fauxItems(6)  = "fauxint.int"
  set fauxItems(7)  = "fauxmvi.mvi"
  set fauxItems(8)  = "fauxmvb.mvb"
  set fauxItems(9)  = "fauxbas.bas"
  set fauxItems(10) = "fauxdfi.dfi"
  set fauxItems(11) = "fauxcsp.csp"
  set fauxItems(12) = "fauxcsr.csr"
  set fauxItems(13) = "fauxhtml.html"
  
  for i=1:1:fauxItems {    
    set contentType = 0       
    set name = fauxItems(i)
    set ext = $piece(name, ".", *)
    set destination = name
    set absoluteFilePath = ##class(%File).NormalizeFilename(..FixtureDirectory_"/"_name)
    if '##class(%File).Exists(absoluteFilePath) continue
    if $lf($lfs("inc,mac,int,dfi,mvi,mvb,bas"), ext) {
      set file = ##class(%FileCharacterStream).%New()
      set file.Filename = absoluteFilePath
      if ##class(%RoutineMgr).Exists(name) {
        do ##class(%RoutineMgr).Delete(name)
      }
      set routine = ##class(%RoutineMgr).%OpenId(name)     
      set sc = routine.Code.CopyFrom(file)
      if $$$ISERR(sc) quit
      set sc = routine.Code.%Save()
      if $$$ISERR(sc) quit
      set routine = ""
      set contentType = 1
    } elseif ext = "cls" {
      set sc = ##class(%Compiler.UDL.TextServices).SetTextFromFile($namespace, ##class(%File).GetFilename(absoluteFilePath), absoluteFilePath)
      if $$$ISERR(sc) quit
    } else {
      set name = $extract($System.CSP.GetDefaultApp($namespace)_"/"_name, 2, *)
      set destination = ##class(Port.Project.Helper).CSPToAbsoluteAppPath(name)
      set sc = ##class(%File).CopyFile(absoluteFilePath, destination, 1, .o)
      if 'sc quit
      set contentType = 2
    }
    set i%ItemsList = $increment(i%ItemsList)
    set i%ItemsList(destination) = contentType
    set file = ""
  }
  return sc
]]></Implementation>
</Method>

<Method name="DisposeFauxItems">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  if $data(i%ItemsList) return $$$OK
  set name = ""
  for {
    set name = $order(i%ItemsList(name), 1, type)
    quit:name=""
    
    if type = 1 do ##class(%Routine).Delete(name)
    if type = 2 do $System.OBJ.Delete(name)
    if type = 3 do ##class(%File).Delete($System.Util.InstallDirectory()_"/csp/"_$$$lcase($namespace)_"/name")
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="AddItemsToProject">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set name = ""
  for {    
    set name = $order(i%ItemsList(name))
    quit:name=""
    
    do ..Project.AddItem(name)
  }
  return $$$OK
]]></Implementation>
</Method>
</Class>


<Class name="Port.UnitTest.Manager">
<Super>%UnitTest.Manager</Super>
<TimeCreated>64306,34529.705584</TimeCreated>

<Method name="Root">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  // This provides us the capability to search for tests unrelated to ^UnitTestRoot.
  return ##class(%File).NormalizeFilename(##class(Port.Configuration).GetWorkspace())
]]></Implementation>
</Method>

<Method name="RunTestsFromWorkspace">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,targetClass:%String="",targetMethod:%String="",targetSpec:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    
  set recursive = "recursive"
  set activeProject = $get(^||Port.Project)
  set ^||Port.Project = projectName
  
  if targetClass '= "" set target = ##class(Port.UnitTest.Util).GetTestPathForClass(targetClass)
  else  set target = ##class(Port.Configuration).GetTestPath()
  
  if targetMethod '= "" {
    set target = target_":"_targetMethod
    set recursive = "norecursive"
  }
  
  set sc = ..RunTest(target_$case(targetSpec, "": "", : ":"_targetSpec), "/"_recursive_"/run/noload/nodelete")
  set ^||Port.Project = activeProject
  return sc
]]></Implementation>
</Method>
</Class>


<Class name="Port.UnitTest.TestCase">
<Super>%UnitTest.TestCase</Super>
<TimeCreated>64306,34529.790238</TimeCreated>

<Method name="GetTestDirectory">
<FormalSpec>filePath:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  
  set testPath = ##class(Port.Configuration).GetTestPath()
  return ##class(%File).NormalizeFilename(filePath, ..Manager.Root()_"/"_testPath)
]]></Implementation>
</Method>
</Class>


<Class name="Port.UnitTest.Util">
<Abstract>1</Abstract>
<TimeCreated>64468,37198.779512</TimeCreated>

<Method name="ResolveTestLocation">
<Final>1</Final>
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>absoluteBasePath:%String,className:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return $listbuild(className_".CLS", ##class(Port.Util).ClassToFile(absoluteBasePath, className, "xml"))
]]></Implementation>
</Method>

<Method name="IsUnitTestClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>className:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  
  set isUnitTest = 0
  set descriptor = ##class(%Dictionary.CompiledClass).%OpenId(className)
  if '$isobject(descriptor) || ($isobject(descriptor) && (descriptor.Super = "")) return 0
  
  if descriptor.Super [ "Port.UnitTest.TestCase" return 1  
  
  // If the target class have some super class defined, we must consider that it could be
  // extending from multiple super classes. So we need to check each of them.
  for i=1:1:$length(descriptor.Super, ",") {
    set extension = $piece(descriptor.Super, ",", i)
    if ..IsUnitTestClass(extension) {
      set isUnitTest = 1
      quit
    }   
  }
  return isUnitTest
]]></Implementation>
</Method>

<Method name="AssertTestableClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>className,*testableClass:%String="",projectName:%String=$get(^||Port.Project)</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if $piece(className, ".", *) = "CLS" set className = $piece(className, ".", 1, *-1)
  set prefix = ##class(Port.Configuration).GetTestClassPrefix()  
  set rootPackage = $piece(className, ".")  
  
  if rootPackage = prefix {
    if '..IsUnitTestClass(className) return 0
    set testableClass = className
  } elseif ##class(%Dictionary.ClassDefinition).%ExistsId(prefix_"."_className) {
    set maybeTestableClass = prefix_"."_className
    if ..IsUnitTestClass(maybeTestableClass) {
      set testableClass = prefix_"."_className
      if '##class(Port.Util).ExistsInProject(projectName, testableClass_".CLS") {
        // Cannot export Unit Test classes that aren't in the project.
        set testableClass = ""
        return 0
      }
    }
  }
  return (testableClass '= "")
]]></Implementation>
</Method>

<Method name="GetTestPathForClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>testableClass:%String,baseTestPath:%String=##class(Port.Configuration).GetTestPath()</FormalSpec>
<Implementation><![CDATA[
  if $extract(baseTestPath, *) = "/" set baseTestPath = $extract(baseTestPath, 1, *-1)
  return baseTestPath_"/"_$piece($replace(testableClass, ".", "/"), "/", 1, *-1)_":"_testableClass
]]></Implementation>
</Method>
</Class>


<Class name="Port.Util">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64470,32188.149177</TimeCreated>

<Method name="ResolveItemExtension">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set ext = $$$ucase($piece(itemName, ".", *))
  set slash = $$$Slash(itemName)
  if $lf($$$RoutineExtensions, "."_ext) || (itemName [ "/") || (ext = "CLS") || (ext = "PRJ") return ext

  if ..IsPackage(itemName) return "PKG"
  return ext
]]></Implementation>
</Method>

<Method name="IsPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  if $get(^oddPKG($$$ucase(itemName))) '= "" return 1
  do $System.OBJ.GetPackageList(.l, itemName)
  if $data(l) return 1

  return 0
]]></Implementation>
</Method>

<Method name="GetItemSourcePathFromWorkspace">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,projectName:%String=$get(^||Port.Project),sourceExtension=##class(Port.Configuration).GetSourceExtension()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set defaultPath = $$$NFN(##class(Port.Configuration).GetWorkspace(projectName))
  return ..MountItemSourcePath(itemName, defaultPath, sourceExtension)
]]></Implementation>
</Method>

<Method name="MountItemNameFromSourcePath">
<ClassMethod>1</ClassMethod>
<FormalSpec>sourcePath:%String,*itemName:%String="",namespace:%String=$namespace,sourceExtension=##class(Port.Configuration).GetSourceExtension()</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set itemName = ""

  if sourceExtension '= "" {
    set type = $piece(sourcePath, ".", *-1)
  } else {
    set type = $piece(sourcePath, ".", *)
  }

  set uppercaseType = $$$ucase(type)
  set sourcePath = $$$NFN(sourcePath)
  set slash = $$$Slash(sourcePath)

  if ..IsRoutine("dummy."_uppercaseType) || (uppercaseType = "CLS") {
    set candidateRoutinePath = sourcePath
    if $extract(candidateRoutinePath) '= "/" set candidateRoutinePath = "/"_candidateRoutinePath
    set itemName = $replace($piece(candidateRoutinePath, slash_type_slash, 2, *), slash, ".")_sourceExtension
    return $$$OK
  }

  $$$QuitOnError(..CSPPhysicalToLogicalPath(sourcePath, .itemName, namespace))
  return $$$OK
]]></Implementation>
</Method>

<Method name="MountItemSourcePath">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String,workspacePath:%String,sourceExtension=##class(Port.Configuration).GetSourceExtension()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set fullPath = ""
  set type = ..ResolveItemExtension(itemName)

  if type = "CLS" {
    set fullPath = ..ClassToFile(workspacePath_"/cls", $piece(itemName, ".", 1, *-1))
  } elseif ..IsRoutine(itemName) {
    set slash = $$$Slash(itemName)
    set itemName = $piece(itemName, slash, *)    
    set ext = $$$lcase(type)
    set fileName = itemName_$select(sourceExtension '= "" : "."_sourceExtension, 1: "")
    set $piece(fileName, ".", *) = ext
    set fullPath = $$$NFN(workspacePath_"/"_ext_"/"_fileName)
  } elseif type = "PKG" {
    // Deep package?
    set name = $replace(itemName, ".PKG", "")
    set fullPath = ..ClassToFile(workspacePath_"/cls", name, sourceExtension, 0)
  } else {
    if $extract(itemName, 1) = "/" set itemName = $extract(itemName, 2, *)
    set sourceFilePath = $replace(itemName, $System.CSP.GetAppName(itemName), "/web/")
    set fullPath = $$$NFN(workspacePath_sourceFilePath)
  }
  return fullPath
]]></Implementation>
</Method>

<Method name="ExtractType">
<ClassMethod>1</ClassMethod>
<FormalSpec>absolutePath:%String,workspace:%String=##class(Port.Configuration).GetWorkspace()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[

  set absolutePath = $$$NFN(absolutePath)
  set absoluteWorkspacePath = $$$NFN(workspace)
  if absolutePath '[ absoluteWorkspacePath return $$$PERROR($$$CouldNotDetermineWorkspace)
  set slash = $$$Slash(absoluteWorkspacePath)

  // + 1 considering the type directory.
  set directoryLength = $length(absoluteWorkspacePath, slash)
  return $$$ucase($piece(absolutePath, slash, directoryLength + 1))
]]></Implementation>
</Method>

<Method name="MountIdFromName">
<ClassMethod>1</ClassMethod>
<FormalSpec>name:%String,projectName:%String=$get(^||Port.Project)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set nameOnly = $piece(name, ".", 1, *-1)
  set maskedMacs = $lb("BAS", "INT", "INC", "MVI")
  set itemName = name
  set id = ""

  set extension = ..ResolveItemExtension(name)

  if ..IsRoutine(name) {
    set itemType = extension
    if $lf(maskedMacs, itemType) set itemType = "MAC"
    set itemName = nameOnly_"."_extension
  } elseif extension = "CLS" {
    set itemName = nameOnly
    set itemType = extension
  } elseif extension = "PKG" {
    set itemName = nameOnly
    set itemType = "PKG"
  } else {
    // Ensures that CSP items starts with normalized path.
    if $extract(name, 1) = "/" {
      set itemName = $replace(name, "/", "", 1, 1)
    }
    set itemType = "CSP"
  }
  return projectName_"||"_itemName_"||"_itemType
]]></Implementation>
</Method>

<Method name="CSPLogicalToPhysicalPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>cspItem:%String,*absolutePath:%String="",namespace:%String=$namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set slash = $$$Slash(absolutePath)
  if $extract(cspItem, 1) = "/" set cspItem = $extract(cspItem, 2, *)
  set cspAppDirectory = $System.CSP.GetAppName(cspItem)
  if cspAppDirectory = "" return $$$PERROR($$$NamespaceDoesntHaveAppWithPath, namespace)
  set cspAppDirectory = $extract(cspAppDirectory, 1, *-1)
  set absolutePath = $$$NFN($replace(cspItem, cspAppDirectory, ##class(Port.Configuration).GetWebAppPath()))
  return $$$OK
]]></Implementation>
</Method>

<Method name="CSPPhysicalToLogicalPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>physicalPath:%String,*logicalPath:%String,namespace:%String=$namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set slash = $$$Slash(physicalPath)
  set webFilePath = $extract(physicalPath, $find(physicalPath, slash_"web"_slash), *)
  if '$find($$$NFN(slash_physicalPath), slash_"web"_slash) {
    return $$$PERROR($$$InvalidPhysicalPath, $$$NFN(physicalPath))
  }

  set cspAppPath = ..AttemptToFindProjectCSPApp(physicalPath, namespace)
  if cspAppPath = "" return $$$PERROR($$$NamespaceDoesntHaveAppWithPath, $namespace)
  if $extract(cspAppPath, *) '[ "/" set cspAppPath = cspAppPath_"/"
  set logicalPath = $extract(cspAppPath, 2, *)_$replace(webFilePath, "\", "/")
  return $$$OK
]]></Implementation>
</Method>

<Method name="AttemptToFindProjectCSPApp">
<ClassMethod>1</ClassMethod>
<FormalSpec>externalPath:%String,namespace:%String=$namespace</FormalSpec>
<Private>1</Private>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set matchingCSPPath = ""
  set candidateCSPPaths = $System.CSP.FilenameToUrls(externalPath)
  &sql(SELECT TOP 1 NAME INTO :matchingCSPPath FROM %STUDIO.PROJECTITEM WHERE NAME %INLIST(:candidateCSPPaths) AND TYPE = 'CSP')
  set cspApp = $piece(matchingCSPPath, "/", 1, *-1)
  if cspApp = "" set cspApp = ..FindApplicationWithPhysicalPath(namespace)
  return cspApp
]]></Implementation>
</Method>

<Method name="IsRoutine">
<ClassMethod>1</ClassMethod>
<FormalSpec>itemName:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
  set extension = ..ResolveItemExtension(itemName)

  if extension = "MAC"  || (extension = "INT") ||
    (extension = "MVB") || (extension = "MVI") ||
    (extension = "BAS") || (extension = "INC") ||
    (extension = "DFI") {
    return 1
  }
  return 0
]]></Implementation>
</Method>

<Method name="ClassToFile">
<ClassMethod>1</ClassMethod>
<FormalSpec>workspacePath:%String,className:%String,extension:%String=##class(Port.Configuration).GetSourceExtension(),appendCLS:%Boolean=1</FormalSpec>
<Implementation><![CDATA[
  set cls = $case(appendCLS, 1: ".cls", : "")
  set slash = $$$Slash(workspacePath)

  if extension '= "" set extension = "."_extension

  return $$$NFN(workspacePath_slash_$replace(className, ".", slash)_cls_extension)
]]></Implementation>
</Method>

<Method name="FileToClass">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String,extension:%String=##class(Port.Configuration).GetSourceExtension()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set slash = $$$Slash(path)
  set path = $$$NFN(path)
  set fileName = ##class(%File).GetFilename(path)
  set extSize = $length($select(extension = "" : $piece(fileName, ".", *), 1: ".cls"_extension))
  set contextPath = $extract(path, $find(path, slash_"cls") + 1, ($length(path) - 1) - extSize)
  return $replace(contextPath, slash, ".")
]]></Implementation>
</Method>

<Method name="ExistsInProject">
<Internal>1</Internal>
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,name:%String,type:%String="",namespace:%String=$namespace</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[

  new $namespace
  set $namespace = namespace

  try {
    do ##class(%Studio.Project).NormalizeName(.name, .type)

    set s = ##class(%SQL.Statement).%New()
    do s.%PrepareClassQuery("%Studio.Project", "ProjectItemsList")
    set r = s.%Execute(projectName)

    while r.%Next(.sc) {
      set itemName = r.%Get("Name")
      set itemType = r.%Get("Type")
      if itemType = type && ($$$lcase(itemName) = $$$lcase(name)) {
        do ##class(%Studio.Project).NormalizeName(.itemName, .itemType)
        if itemName = name return 1
      }
    }
  } catch ex {
    return 0
  }

  return 0
]]></Implementation>
</Method>

<Method name="GetProjectFromResolvedPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>workspacePath:%String,*project:%Studio.Project=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set projectName = $piece(workspacePath, $$$PathSlash(workspacePath), *)
  set project = ##class(%Studio.Project).%OpenId(projectName)

  if $isobject(project) {
    // Ensure that the project name reported matches the existing one.
    set projectName = project.Name
    return project
  } elseif $data(^Port.Configuration("workspace.project")) {
    // Attempt to locate the project name by matching the path.
    set project = $$ScanWorkspacesRegistry(workspacePath)
  }

  if '$isobject(project) {
    quit $$$PERROR($$$ExportingProjectNotFound, projectName)
  }

  return $$$OK

ScanWorkspacesRegistry(intendedPath)
  set workspaceProject = ""
  for {
    set workspaceProject = $order(^Port.Configuration("workspace.project", workspaceProject), 1, candidatePath)
    quit:workspaceProject=""

    set resolvedPath = ##class(Port.Configuration).RewritePlaceHolders(candidatePath, projectName, $lb("{NAMESPACE}","{INSTALLDIR}","{PROJECT}","{USERNAME}"))

    if candidatePath = intendedPath {
      return ##class(%Studio.Project).%OpenId(workspaceProject)
    }
  }
  return ""
]]></Implementation>
</Method>

<Method name="ListConflicts">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,name:%String,type:%String=""</FormalSpec>
<ReturnType>%List</ReturnType>
<Implementation><![CDATA[
  do ##class(%Studio.Project).NormalizeName(.name, .type)
  if type = "CLS" set packages = $$SplitPackages(name)
  &sql(
    SELECT
      LIST(DISTINCT P.NAME) INTO :ubiquitousEntries
    FROM
      %STUDIO.PROJECTITEM PI
    LEFT OUTER JOIN
      %STUDIO.PROJECT P ON P.ID = PI.Project
    WHERE
      P.NAME <> :projectName AND (
       -- This deals with common cases.
       (:type NOT IN ('PKG', 'CLS') AND PI.NAME = :name) OR
       -- This deals with cases where a project is trying to add a package that is
       -- depended by another class in another project.
       (:type = 'PKG' AND PI.NAME %STARTSWITH :name) OR
       -- This deals with attempts to add classes that are owned by another project's
       -- package.z
       (:type = 'CLS' AND PI.NAME %INLIST(:packages))
      )
  )
  return $lfs(ubiquitousEntries)

SplitPackages(className)
  set splittedPackages = ""
  set packageLength = $length(className, ".")
  for i=packageLength:-1:2 {
    set $list(splittedPackages, *+1) = $piece(className, ".", 1, i)
  }
  quit splittedPackages
]]></Implementation>
</Method>

<Method name="CreateMissingPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set absolutePath = $$$NFN(path)
  set isCreated = 1
  if '##class(%File).DirectoryExists(absolutePath)  {
    set isCreated = ##class(%File).CreateDirectoryChain(absolutePath)
    if isCreated = 0 {
      return $$$PERROR($$$CannotCreateDirectory, absolutePath)
    }
  }
  return $$$OK
]]></Implementation>
</Method>

<Method name="GetIgnoredPaths">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String=$get(^||Port.Project)</FormalSpec>
<ReturnType>%ListOfDataTypes</ReturnType>
<Implementation><![CDATA[
  set workspaceDir = ##class(Port.Configuration).GetWorkspace(projectName)
  set ignoredPaths = ##class(%ListOfDataTypes).%New()

  set f = ##class(%FileCharacterStream).%New()
  set f.Filename = workspaceDir_"/.portignore"

  if f.Size > 0 {
    while 'f.AtEnd {
      do ignoredPaths.Insert(f.ReadLine())
    }
  }
  return ignoredPaths
]]></Implementation>
</Method>

<Method name="TranslatePath">
<ClassMethod>1</ClassMethod>
<FormalSpec>path:%String,OSFormat:%Integer=$zversion(1)</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  // Unix
  if OSFormat = 3 {
    if $extract(path, 1, 2)?1A1":" {
      set path = $extract(path, 3, *)
    }
    return $replace(path, "\", "/")
  // Windows
  } elseif OSFormat = 2 {
    set path = $replace(path, "/", "\")
    if $extract(path) = "\" {
      set path = ##class(%File).NormalizeFilename("\")_path
    }
  }
  return path
]]></Implementation>
</Method>

<Method name="ResolveWorkspaceFromPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>file:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set types = $lfs($$$RoutinesGroups_",WEB,CLS,OTH")
  set slash = $$$Slash(file)
  for i=1:1:$ll(types) {
    set type = $$$lcase($lg(types, i))
    set pathType = slash_type_slash
    if file [ pathType {
      set chainParts = $lfs(file, slash)
      set typeIndex = $lf(chainParts, type)
      return $piece(file, slash, 1, typeIndex - 1)
    }
  }
  return ""
]]></Implementation>
</Method>

<Method name="IsOutdated">
<ClassMethod>1</ClassMethod>
<FormalSpec>project:%String,current:%String,external:%String,isImport:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  if '##class(%File).Exists(external) return 1
  set externalTS = $zdt(##class(%File).GetFileDateModified(##class(%File).NormalizeFilename(external)), 3,,,,,,,,,0)

  if externalTS < 0 return 1
  set lastModified = 0

  set projectTS = ##class(Port.SourceControl.Log).GetLastChange(project, project_".PRJ")
  set currentDate = ##class(Port.SourceControl.Log).GetLastChange(project, current)

  if currentDate = 0 set lastModified = projectTS
  else  set lastModified = $select(currentDate ] projectTS : currentDate, 1: projectTS)

  if ##class(Port.Util).IsRoutine(current) ||
    (##class(Port.Util).ResolveItemExtension(current) = "CLS") {
    set currentTS = $piece(##class(%RoutineMgr).TS(current, .compileTime), ".")
  } else {
    set fullSourcePath = ""
    if 'isImport {
      do ##class(Port.Util).CSPLogicalToPhysicalPath(current, .fullSourcePath)
    } else {
      do ##class(Port.Util).CSPPhysicalToLogicalPath(current, .fullSourcePath)
    }
    set currentTS = $zdatetime(##class(%File).GetFileDateModified(fullSourcePath), 3,,,,,,,,,0)
  }

  // If the file or the item is missing it's considered outdated as well.
  if currentTS = 0 return 1

  // Same date for both entries? Then consider updated.
  if currentTS = externalTS return 0
  if 'isImport {
    if currentTS = "" return 1
    // As currentTS is referring to the imported source code, this condition checks if
    // it is newer than the file exported last time, we also keep a registry
    // about changes made using Port so we check against it as well.
    return (
      (currentTS ] externalTS) &&
      (currentTS ] lastModified)
    )
  }
  // Otherwise everything is inverted:
  // External files must be newer than the imported source code and newer than their last
  // registry as well.
  return (
    (externalTS ] currentTS) &&
    (externalTS ] lastModified)
  )
]]></Implementation>
</Method>

<Method name="FindApplicationWithPhysicalPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>namespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  new $namespace
  set $namespace = "%SYS"

  set statement = ##class(%SQL.Statement).%New()
  do statement.%PrepareClassQuery("Security.Applications", "NamespaceList")
  set cursor = statement.%Execute(namespace)

  set appName = ""

  while cursor.%Next() {
    set path = cursor.%Get("Path")
    if path '= "" set appName = cursor.%Get("Name") quit
  }

  return appName
]]></Implementation>
</Method>
</Class>


<Class name="Port.Wizard">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64399,33218.690245</TimeCreated>

<Method name="Start">
<ClassMethod>1</ClassMethod>
<FormalSpec>hideIntroduction:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set validChoices = $listbuild(1,2,3,4,5,6)
  set invalidChoice = 1
  set choice = ""  
  
  if 'hideIntroduction {
    write !, $$$FormatWizardMsg($$$PCWWelcome)
  }
  
  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice)
    do Menu
  }
    
  if choice = 1 return ..StartWorkspaceConfigAssistant() quit
  if choice = 2 return ..StartTestConfigAssistant() quit
  if choice = 3 return ..StartAutoExportXMLConfigAssistant() quit
  if choice = 4 return ..StartLogLevelConfigAssistant() quit
  if choice = 5 return ..StartSourceExtensionConfigAssistant() quit
  if choice = 6 write !, $$$FormatWizardMsg($$$PCWBye) return $$$OK
         
Menu
  set choice = ""
  write !!, $$$FormatWizardMsg($$$PCWChoiceQuestion), !!
  
  write $$$FormatWizardMsg($$$PCWManageWorkspaceChoice), !
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice), !
  write $$$FormatWizardMsg($$$PCWToggleAutoExportChoice), !
  write $$$FormatWizardMsg($$$PCWSetLogLevelChoice), !
  write $$$FormatWizardMsg($$$PCWSetSourceExtensionChoice), !
  write $$$FormatWizardMsg($$$PCWExit), !!
  
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  write !  
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  quit
]]></Implementation>
</Method>

<Method name="StartWorkspaceConfigAssistant">
<ClassMethod>1</ClassMethod>
<FormalSpec>hideIntroduction:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
 
  set validChoices = $listbuild(1,2,3)
  set invalidChoice = 1
  set choice = ""    
  
  if 'hideIntroduction {  
    write !, $$$FormatWizardMsg($$$PCWManageWorkspaceDescription), !!
  }
  
  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice), !!
    do Menu
  }
  
  if choice = 1 return ..StartWorkspaceChoice1ConfigAssistant()
  if choice = 2 return ..StartWorkspaceChoice2ConfigAssistant()
  if choice = 3 return ..Start(1) 
  
  return $$$OK
    
Menu
  set choice = ""
  write !, $$$FormatWizardMsg($$$PCWChoiceQuestion), !!

  write $$$FormatWizardMsg($$$PCWManageWorkspaceChoice1), !
  write $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2), !
  write $$$FormatWizardMsg($$$PCWGoBackChoice, "3"), !!
  
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  write !  
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  quit
]]></Implementation>
</Method>

<Method name="StartWorkspaceChoice1ConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set isPathValid = 0
      
  write !, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice1Description)
  
  write !!, $$$FormatWizardMsg($$$PCWPlaceholdersAnnounce), !!
  
  write $$$FormatWizardMsg($$$PCWPlaceholdersProject), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersNamespace), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersUsername), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersInstallDir)
  
  write !!, $$$FormatWizardMsg($$$PCWPathAbsolute), !!
 
  write $$$FormatWizardMsg($$$PCWPathOSSchemes), !!
  write $$$FormatWizardMsg($$$PCWPathDefault), !, "/CacheProjects/{NAMESPACE}/{PROJECT}", !
  write $$$FormatWizardMsg($$$PCWPathCurrent), !, $get(^Port.Configuration("source.path"), "none"), !!
  write $$$FormatWizardMsg($$$PCWPathNew), !
  read path
  
  if path = "" set path = "/CacheProjects/{NAMESPACE}/{PROJECT}"
    
  do ##class(Port.Configuration).SetPrimaryWorkspace(path)
  write !!, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice1StatusNow, path), !
  return ..StartWorkspaceConfigAssistant(1)
]]></Implementation>
</Method>

<Method name="StartWorkspaceChoice2ConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  write !, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2Description), ! 
  write !, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2Description2), !
  
  write !, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2Prompt), !
  read projectName
  
  if projectName = "" write !, $$$FormatWizardMsg($$$PCWAborted), !! return ..StartWorkspaceConfigAssistant(1)
  set projectExists = ##class(%Studio.Project).%ExistsId(projectName)
  
  if 'projectExists {
    write !!, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2Warning), !!
  }  
  
  set currentWorkspace = ##class(Port.Configuration).GetCustomWorkspace(projectName)
  write !!, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice1StatusCurrent, ##class(Port.Configuration).GetWorkspace(projectName)), !
  write !, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2CurrentWorskpaceWarn)
  
  write !!, $$$FormatWizardMsg($$$PCWPathAbsolute), !!
  
  write $$$FormatWizardMsg($$$PCWPlaceholdersProject), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersNamespace), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersUsername), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersInstallDir)
    
  write !!, $$$FormatWizardMsg($$$PCWPathOSSchemes) 
  
  write !!, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2Prompt2), !
  read workspacePath
  
  if workspacePath = "" write !, $$$FormatWizardMsg($$$PCWAborted), !! return ..StartWorkspaceConfigAssistant(1)
  
  do ##class(Port.Configuration).SetCustomWorkspace(projectName, workspacePath)
  write !!, $$$FormatWizardMsg($$$PCWManageWorkspaceChoice2StatusNow, projectName, ##class(Port.Configuration).GetWorkspace(projectName)), !
  
  return ..StartWorkspaceConfigAssistant(1)
]]></Implementation>
</Method>

<Method name="StartTestConfigAssistant">
<ClassMethod>1</ClassMethod>
<FormalSpec>hideIntroduction:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  set validChoices = $listbuild(1,2,3,4)
  set invalidChoice = 1
  set choice = ""    
  
  if 'hideIntroduction {  
    write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsDescription), !
  }
  
  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice), !!
    do Menu
  }
  
  if choice = 1 return ..StartTestChoice1ConfigAssistant()
  if choice = 2 return ..StartTestChoice2ConfigAssistant()
  if choice = 3 return ..StartTestChoice3ConfigAssistant()
  if choice = 4 return ..Start(1)
  
  return $$$OK
    
Menu
  set choice = ""
  write !, $$$FormatWizardMsg($$$PCWChoiceQuestion), !!
  
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1), !
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice2), !
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice3), !
  write $$$FormatWizardMsg($$$PCWGoBackChoice, 4), !!
  
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  write !  
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  quit
]]></Implementation>
</Method>

<Method name="StartAutoExportXMLConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set validChoices = $listbuild(1,2)
  set choice = ""
  set invalidChoice = 1
  
  set labels(0) = $$$FormatWizardMsg($$$PCWToggleDisabled)
  set labels(1) = $$$FormatWizardMsg($$$PCWToggleEnabled)
  
  write !, $$$FormatWizardMsg($$$PCWToggleAutoExportDescription), !

  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice), !!
    do Menu
  }
  
  if choice = 1 do ##class(Port.Configuration).EnableAutoExportXML()
  if choice = 2 do ##class(Port.Configuration).DisableAutoExportXML() set choice = 0
    
  write $$$FormatWizardMsg($$$PCWToggleAutoExportChoice1StatusCurrent, labels(choice))
  
  write !!
  return ..Start(1)
  
Menu
  set choice = ""
  write !, $$$FormatWizardMsg($$$PCWChoiceQuestion), !!
    
  write $$$FormatWizardMsg($$$PCWToggleAutoExportChoice1), ! 
  write $$$FormatWizardMsg($$$PCWToggleAutoExportChoice2), !!  
     
  set status = ##class(Port.Configuration).IsAutoExportXMLEnabled()
  
  write $$$FormatWizardMsg($$$PCWToggleAutoExportChoice1StatusCurrent, labels(status)), !!
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  write !
  quit
]]></Implementation>
</Method>

<Method name="StartLogLevelConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set validChoices = $listbuild(1,2)
  set invalidChoice = 1
  set choice = ""
  
  write !, $$$FormatWizardMsg($$$PCWSetLogLevelDescription), !
  
  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice), !!
    do Menu
  }
  
  do ##class(Port.Configuration).SetLogLevel(choice)
  write $$$FormatWizardMsg($$$PCWSetLogLevelStatusNow, ##class(Port.Configuration).GetLogLevel())
  return ..Start(1)
  
Menu
  set choice = ""
  write !, $$$FormatWizardMsg($$$PCWSetLogLevelStatusPrompt), !!
    
  write $$$FormatWizardMsg($$$PCWSetLogLevelStatusChoice1), !!
  
  write $$$FormatWizardMsg($$$PCWSetLogLevelStatusChoice2), !!
  
  write $$$FormatWizardMsg($$$PCWSetLogLevelStatusCurrent, ##class(Port.Configuration).GetLogLevel()), !!
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  write !
  quit
]]></Implementation>
</Method>

<Method name="StartSourceExtensionConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set currentExtension = $get(^Port.Configuration("source.extension"))
  write !, $$$FormatWizardMsg($$$PCWSetSourceExtensionDescription), !
  
  write $$$FormatWizardMsg($$$PWCSetSourceExtensionPrompt), !!
  write $$$FormatWizardMsg($$$PCWPathDefault), !
  write $select(currentExtension = "" : "none.", 1: "."_currentExtension), !
  write $$$FormatWizardMsg($$$PCWPathNew)
  read extension   
  
  do ##class(Port.Configuration).SetSourceExtension(extension)
  set savedExtension = $get(^Port.Configuration("source.extension"))
  write !!, $$$FormatWizardMsg($$$PWCSetSourceExtensionStatusNow, $select(savedExtension = "" : "none.", 1: "."_savedExtension))
  return ..Start(1)
]]></Implementation>
</Method>

<Method name="StartTestChoice1ConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set validChoices = $listbuild(1,2)  
  set invalidChoice = 1
  set choice = ""
  
  set labels(0) = $$$FormatWizardMsg($$$PCWToggleEnabled)
  set labels(1) = $$$FormatWizardMsg($$$PCWToggleDisabled)
  
  write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1Description), !  
  
  while invalidChoice {
    if invalidChoice && (choice '= "") write $$$FormatWizardMsg($$$PCWInvalidChoice), !!
    do Menu
  }
  
  if choice = 1 do ##class(Port.Configuration).EnableTestOnDemand()      
  if choice = 2 do ##class(Port.Configuration).DisableTestOnDemand()
  
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1StatusCurrent, labels(choice - 1))
  
  write !
  return ..StartTestConfigAssistant(1)
  
Menu
  set choice = ""
  write !, $$$FormatWizardMsg($$$PCWChoiceQuestion), !!
    
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1Choice1), ! 
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1Choice2), !! 
     
  set status = ##class(Port.Configuration).IsTestOnDemandEnabled()
  
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1StatusCurrent, labels(status)), !
  write $$$FormatWizardMsg($$$PCWChoicePrompt)
  
  read choice
  set invalidChoice = ($listfind(validChoices, choice) = 0)
  write !
  quit
]]></Implementation>
</Method>

<Method name="StartTestChoice2ConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  
  write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice1Description), !
  write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice2Description), !
  write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice3Description), !!
  
  write $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice2Prompt), !  
  write $$$FormatWizardMsg($$$PCWPathDefault), " UnitTest", !
  write $$$FormatWizardMsg($$$PCWPathCurrent), " ", ##class(Port.Configuration).GetTestClassPrefix(), !!
  write $$$FormatWizardMsg($$$PCWPathNew)
  read prefix   
  
  do ##class(Port.Configuration).SetTestClassPrefix(prefix)
  write !!, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice2StatusNow, ##class(Port.Configuration).GetTestClassPrefix())
  write !!
  return ..StartTestConfigAssistant(1)
]]></Implementation>
</Method>

<Method name="StartTestChoice3ConfigAssistant">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  write !, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice3Description)
  
  write !!, $$$FormatWizardMsg($$$PCWPlaceholdersAnnounce), !!
  
  write $$$FormatWizardMsg($$$PCWPlaceholdersProject), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersNamespace), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersUsername), !
  write $$$FormatWizardMsg($$$PCWPlaceholdersInstallDir)
  
  write !!, $$$FormatWizardMsg($$$PCWPathRelative), !
    
  write $$$FormatWizardMsg($$$PCWPathDefault), !, "tests", !
  write $$$FormatWizardMsg($$$PCWPathCurrent), !, $get(^Port.Configuration("test.path")), !!
  write $$$FormatWizardMsg($$$PCWPathNew), !
  read path
   
  do ##class(Port.Configuration).SetTestPath(path)
  write !!, $$$FormatWizardMsg($$$PCWManageChangeTestSettingsChoice3StatusNow, ^Port.Configuration("test.path"))
  write !!
  return ..StartTestConfigAssistant(1)
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Port.Helper">
<Abstract>1</Abstract>
<IncludeCode>portutils</IncludeCode>
<TimeCreated>64474,31749.573977</TimeCreated>

<Parameter name="MOCKAPPNAME">
<Default>/unittest/mockapp</Default>
</Parameter>

<Method name="CreateMockApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ns = $namespace
  new $namespace
  
  set $namespace = "%SYS"
  set properties("Path") = ##class(%File).NormalizeFilename($System.Util.InstallDirectory()_"csp/mockapp")
  set properties("NameSpace") = ns
  set properties("IsNameSpaceDefault") = 1
  
  if ##class(Security.Applications).Exists(..#MOCKAPPNAME) {
    $$$QuitOnError(..DestroyMockApplication())
  }
  return ##class(Security.Applications).Create(..#MOCKAPPNAME, .properties)
]]></Implementation>
</Method>

<Method name="DestroyMockApplication">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set ns = $namespace
  new $namespace
  
  set $namespace = "%SYS"
  do ##class(%File).RemoveDirectoryTree($System.Util.InstallDirectory()_"csp/mockapp")
  return ##class(Security.Applications).Delete(..#MOCKAPPNAME)
]]></Implementation>
</Method>

<Method name="MockItems">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,*items:%List="",*outputs:%List=""</FormalSpec>
<Implementation><![CDATA[
  set slash = $select($$$isWINDOWS : "\", 1: "/")
  #define CurrentWorkspace(%item) $$$NFN($$$FormatText("%1%2%3", ##class(Port.Configuration).GetWorkspace(projectName), "/", %item))
  
  set currentApp = $extract($System.CSP.GetDefaultApp($namespace), 2, *)
  set a = $lb("PKG", "CLS", "CLS", "PKG", "PKG", "INC", "MAC", "DFI", "BAS", "MVB", "MVI", "CSP", "HTML", "HTML", "JS", "HTML", "ONLYEXTENSION", "PRJ")
  
  set items = $lb(
    "Dummy.PKG",
    "Dummy.Class.CLS",
    "Dummy.Another.Package.Here.CLS",
    "Dummy.And.Here.We.Shall.Test.Packages.PKG",
    "Dummy.And.Here.We.Shall.Test.Packages.Without.Extension.PKG",
    "dummy.INC",
    "dummy.MAC",
    "dummy.DFI",
    "dummy.BAS",
    "dummy.MVB",
    "dummy.MVI",
    $$$FormatText("%1/dummy/index.csp", currentApp), 
    $$$FormatText("%1/dummy/index.html", currentApp),
    $$$FormatText("%1/dummy/composite.name.should.still.resolve.html", currentApp),
    $$$FormatText("%1/dummy/js/some/deep/file.js", currentApp),
    $$$FormatText("%1/dummy/js/some/deep/file.html", currentApp),
    $$$FormatText("%1/dummy/js/some/deep/.onlyextension", currentApp)
  )
  
  set outputs = $lb(
    $$$CurrentWorkspace("cls/Dummy"),
    $$$CurrentWorkspace("cls/Dummy/Class.cls"),
    $$$CurrentWorkspace("cls/Dummy/Another/Package/Here.cls"),
    $$$CurrentWorkspace("cls/Dummy/And/Here/We/Shall/Test/Packages"),
    $$$CurrentWorkspace("cls/Dummy/And/Here/We/Shall/Test/Packages/Without/Extension"),
    $$$CurrentWorkspace("inc/dummy.inc"),
    $$$CurrentWorkspace("mac/dummy.mac"),
    $$$CurrentWorkspace("dfi/dummy.dfi"),
    $$$CurrentWorkspace("bas/dummy.bas"),
    $$$CurrentWorkspace("mvb/dummy.mvb"),
    $$$CurrentWorkspace("mvi/dummy.mvi"),
    $$$CurrentWorkspace("web/dummy/index.csp"),
    $$$CurrentWorkspace("web/dummy/index.html"),
    $$$CurrentWorkspace("web/dummy/composite.name.should.still.resolve.html"),
    $$$CurrentWorkspace("web/dummy/js/some/deep/file.js"),
    $$$CurrentWorkspace("web/dummy/js/some/deep/file.html"),
    $$$CurrentWorkspace("web/dummy/js/some/deep/.onlyextension")    
  )
]]></Implementation>
</Method>

<Method name="CreateDummyProject">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set dummy = ##class(%Studio.Project).%New()
  set dummy.Name = "dummy-project"
  do dummy.AddItem("Port.SourceControl.AutoInstall.CLS")
  set sc = dummy.%Save()
  quit sc
]]></Implementation>
</Method>

<Method name="RemoveDummyProjectItem">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
  set dummy = ##class(%Studio.Project).%OpenId("dummy-project")
  do dummy.RemoveItem("Port.SourceControl.AutoInstall.CLS")
  quit dummy.%Save()
]]></Implementation>
</Method>

<Method name="CloneTestProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>fixturePath:%String,projectName:%String,usingXMLOnly:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   
  set source = $$$NFN($$$FormatText("%1/%2", fixturePath, projectName))
  set dest = $$$NFN($$$FormatText("%1/_/%2", fixturePath, projectName))
  if 'usingXMLOnly {
    set copied = ##class(%File).CopyDir(source, dest,,.created, 1)
    if 'copied return $$$PERROR($$$UnableToCopySource, source, dest)
  } else {
    set originXML = $$$NFN($$$FormatText("%1/%2.xml", source, projectName))
    set destinationXML = $$$NFN($$$FormatText("%1/%2.xml", dest, projectName))
    do ##class(%File).CreateDirectoryChain(##class(%File).GetDirectory(destinationXML))
    set copied = ##class(%File).CopyFile(originXML, destinationXML, 1)
    if 'copied return $$$PERROR($$$UnableToCopySource, source, dest)
  }
    
  $$$QuitOnError(##class(%Studio.Project).Import($$$FormatText("%1/%2.xml", dest, projectName), "/nodisplay"))
  // We don't want to overwrite the original dummy-project, but the clone instead.
  do ##class(Port.Configuration).SetCustomWorkspace(projectName, dest)
  
  return $$$OK
]]></Implementation>
</Method>

<Method name="DeleteTestProject">
<ClassMethod>1</ClassMethod>
<FormalSpec>fixturePath:%String,projectName:%String="dummy-project"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set rows = ##class(%SQL.Statement).%ExecDirect(, "SELECT NAME FROM %STUDIO.PROJECTITEM WHERE PROJECT = ?", projectName)
  while rows.%Next(.sc) {
    if $$$ISERR(sc) return sc
    set itemName = rows.%Get("Name")
    set isClass = ##class(%Dictionary.ClassDefinition).%ExistsId(itemName)
    
    if (##class(Port.Util).IsRoutine(itemName) || 
        ##class(%RoutineMgr).IsCSPName(itemName) ||
        isClass
    ) {
      // We use %SYSTEM.OBJ.Delete here because it supports qualifiers and we don't want to pollute the test feedback.
      if isClass set sc = $System.OBJ.Delete(itemName, "/nodisplay")
      else  set sc = ##class(%RoutineMgr).Delete(itemName)
      if $$$ISERR(sc) return sc
    } else {
      set sc = ##class(Port.Util).CSPPhysicalToLogicalPath(itemName, .logicalPath)
      if $$$ISERR(sc) return sc
      set sc = ##class(%File).Delete(logicalPath)
      if $$$ISERR(sc) return sc
    }
  }
  set normalizedTargetDir = $$$NFN($$$FormatText("%1/_", fixturePath))
  
  set removed = ##class(%File).RemoveDirectoryTree(normalizedTargetDir)
  if 'removed return $$$PERROR($$$UnableToRemoveDirectory, normalizedTargetDir)
  
  do ##class(Port.Configuration).RemoveCustomWorkspace(projectName)
  return $System.OBJ.DeleteProject(projectName)
]]></Implementation>
</Method>

<Method name="GetTestProjectItemsPath">
<ClassMethod>1</ClassMethod>
<FormalSpec>projectName:%String,fixturePath:%String</FormalSpec>
<ReturnType>%ArrayOfDataTypes</ReturnType>
<Implementation><![CDATA[
  set locations = ##class(%ArrayOfDataTypes).%New()
  set rows = ##class(%SQL.Statement).%ExecDirect(, "SELECT NAME, TYPE FROM %STUDIO.PROJECTITEM WHERE PROJECT = ?", projectName)
  while rows.%Next(.sc) {
    if $$$ISERR(sc) return sc
    set type = rows.%Get("Type")
    set itemName = rows.%Get("Name")
    
    if type = "CLS" set itemName = itemName_".CLS"
    set location = ##class(Port.Util).MountItemSourcePath(itemName, fixturePath)
    
    do locations.SetAt(location, itemName)
  }
  quit locations
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Port.Logger">
<IncludeCode>portutils</IncludeCode>
<Super>Port.UnitTest.TestCase</Super>
<TimeCreated>64468,35385.190031</TimeCreated>

<Property name="Logger">
<Type>Port.Logger</Type>
</Property>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..Logger = ##class(Port.Logger).%New()
  quit $$$OK
]]></Implementation>
</Method>

<Method name="TestOnNew">
<Implementation><![CDATA[
  do $$$AssertEquals(2, ..Logger.LogLevel, "defaults to level 2")

  set logger = ##class(Port.Logger).%New(1)
  do $$$AssertEquals(1, logger.LogLevel, "can ovewrite log using the constructor")

  set sc = $$$OK

  try {
    set logger = ##class(Port.Logger).%New(3)
  } catch ex {
    set sc = ex.AsStatus()
  }

  do $$$AssertStatusNotOK(sc, "throws if level is out of range")
]]></Implementation>
</Method>

<Method name="TestLog">
<Implementation><![CDATA[

  set expectedText = "[Port] "_$$$FormatMsg("Port Log Messages", $$$ImportingProject, "dummy")

  do $$$AssertEquals(..Logger.Log($$$ImportingProject, 0, "dummy"), expectedText, "can receive arity params")
  do $$$AssertEquals(..Logger.Log($$$NoExtraneousItems, 0), "[Port] "_$$$FormatMsg("Port Log Messages", $$$NoExtraneousItems), "does not break if no arity is passed")

  set ..Logger.LogLevel = 1
  do $$$AssertEquals(..Logger.Log($$$ImportingProject, 2, "dummy"), "", " DO NOT WRITE the message if level is higher than log level")

  set ..Logger.LogLevel = 2
  do $$$AssertEquals(..Logger.Log($$$ImportingProject, 1, "dummy"), expectedText, "DO WRITE the message if level is lower than log level")

  set ..Logger.LogLevel = 2
  do $$$AssertEquals(..Logger.Log($$$ImportingProject, 2, "dummy"), expectedText, "DO WRITE the message if level equals log level")
]]></Implementation>
</Method>

<Method name="TestLogLine">
<Implementation><![CDATA[
  set expectedText = "[Port] "_$$$FormatMsg("Port Log Messages", $$$ImportingProject, "dummy")_$c(13, 10)
  do $$$AssertEquals(..Logger.LogLine($$$ImportingProject, 0, "dummy"), expectedText, "breaks to a new line")
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Port.Project.Exporter">
<Super>Port.UnitTest.TestCase,UnitTest.Port.Helper</Super>
<TimeCreated>64426,56009.879156</TimeCreated>

<Property name="Exporter">
<Type>Port.Project.Exporter</Type>
</Property>

<Property name="ConfiguredExtension">
<Type>%String</Type>
</Property>

<Method name="OnBeforeAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ..ConfiguredExtension = ##class(Port.Configuration).GetSourceExtension()
  do ##class(Port.Configuration).SetSourceExtension("")
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterAllTests">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  do ##class(Port.Configuration).SetSourceExtension(..ConfiguredExtension)
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
     
  $$$QuitOnError(..CloneTestProject(..GetTestDirectory("../fixtures"), "dummy-project", 1))
  set ..Exporter = ##class(Port.Project.Exporter).%New(..GetTestDirectory("../fixtures/_/dummy-project"))
  // Turn off logger notification to prevent breaking test feedbacks.
  set ..Exporter.Logger.Silent = 1
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  $$$QuitOnError(..DeleteTestProject(..GetTestDirectory("../fixtures"), "dummy-project"))
  set ..Exporter = ""
  return $$$OK
]]></Implementation>
</Method>

<Method name="TestOnNew">
<Implementation><![CDATA[
  set exporter = ""
  
  try {
    set exporter = ##class(Port.Project.Exporter).%New("/this/does/not/exist")
  } catch ex {
    do $$$AssertStatusNotOK(ex.AsStatus(), "does not accept inexistent projects")
  }
]]></Implementation>
</Method>

<Method name="TestExportItem">
<FormalSpec>ovewrite:%Boolean=0</FormalSpec>
<Implementation><![CDATA[
  #define ItemPath(%itemName) ##class(Port.Util).GetItemSourcePathFromWorkspace(%itemName, "dummy-project")  
  
  set sc = $$$OK
  set items = ..GetTestProjectItemsPath("dummy-project", ..GetTestDirectory("../fixtures/_/dummy-project"))
  set itemName = ""
  
  do ##class(Port.Util).CSPPhysicalToLogicalPath(..GetTestDirectory("../fixtures/_/dummy-project/web/dummy.html"), .missingFile)
  
  for missingItem = "I.Dont.Exist.CLS", "idontexist.mac", "idontexist.inc", "idontexist.dfi", missingFile {
    do items.SetAt(##class(Port.Util).GetItemSourcePathFromWorkspace(missingItem, "dummy-project"), missingItem)
  }
  
  for i=1:1:items.Count() {
    set itemName = items.Next(itemName)
    set itemLocation = items.GetAt(itemName)
    set sc = ..Exporter.ExportItem(itemName)
    if ##class(Port.Util).ExistsInProject("dummy-project", itemName) {
      if $$$ISERR(sc) quit
      set isSameFile = ##class(%File).Compare($$$ItemPath(itemName), ##class(Port.Util).MountItemSourcePath(itemName, ..GetTestDirectory("../fixtures/dummy-project")))
      if 'isSameFile {
        break
        set sc = $$$ERROR($$$GeneralError, $$$FormatText("files for %1 don't match", itemName))
        quit
      }
    }
  }
  //do $$$AssertStatusOK(sc, "exports items individually")
]]></Implementation>
</Method>

<Method name="TestExport">
<Implementation><![CDATA[
  #define ItemPath(%itemName) ##class(Port.Util).GetItemSourcePathFromWorkspace(%itemName, "dummy-project")
  
  set items = ..GetTestProjectItemsPath("dummy-project", ..GetTestDirectory("../fixtures/_/dummy-project"))
  set itemName = ""
  set sc = $$$OK
  
  set ..Exporter.Overwrite = 1
  set sc = ..Exporter.Export()
  
  if $$$ISOK(sc) {
    for i=1:1:items.Count() {
      set itemName = items.Next(itemName)
      set itemLocation = items.GetAt(itemName)    
      if ##class(Port.Util).ExistsInProject("dummy-project", itemName) {
        if '##class(%File).Exists(itemLocation) {
          set sc = $$$ERROR($$$GeneralError, $$$FormatText("file not generated for item %1", itemName))
          quit        
        }
      }       
    }
  }
  do $$$AssertStatusOK(sc, "exports all project files")
  quit
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Port.Project.Synchronizer">
<Super>Port.UnitTest.TestCase,UnitTest.Port.Helper</Super>
<TimeCreated>64471,56194.658409</TimeCreated>

<Property name="Exporter">
<Type>Port.Project.Exporter</Type>
</Property>

<Method name="OnBeforeOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  $$$QuitOnError(..CloneTestProject(..GetTestDirectory("../fixtures"), "dummy-project"))
  set ..Exporter = ##class(Port.Project.Exporter).%New(..GetTestDirectory("../fixtures/_/dummy-project"), 1)
  set ..Exporter.Logger.Silent = 1  
  return $$$OK
]]></Implementation>
</Method>

<Method name="OnAfterOneTest">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[  return ..DeleteTestProject(..GetTestDirectory("../fixtures"), "dummy-project")
]]></Implementation>
</Method>

<Method name="TestPurge">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  set synchronizer = ##class(Port.Project.Synchronizer).%New(..Exporter)
  
  do synchronizer.AddToWhitelist("Dummy.Package.Class.CLS")
  do synchronizer.AddToWhitelist("dummy.MAC")
  do synchronizer.AddToWhitelist("dummy.INC")
  do synchronizer.AddToWhitelist("dummy.MVB")
  do synchronizer.AddToWhitelist($System.CSP.GetDefaultApp($namespace)_"/index.html")
  do synchronizer.AddToWhitelist("MVB.4.MVI")
  do synchronizer.AddToWhitelist("dummy.DFI")
  
  set sc = synchronizer.Purge()
  
  set items = ..GetTestProjectItemsPath("dummy-project", ..GetTestDirectory("../fixtures/_/dummy-project"))
  set itemName = ""
  set templateAssertion = "%1 -> %2"
  for i=1:1:items.Count() {
    set itemName = items.Next(itemName)
    set itemLocation = items.GetAt(itemName)
    set flag = $lf($lb("dummy.MAC", "dummy.INC", "dummy.MVB", "dummy.DFI", $e($System.CSP.GetDefaultApp($namespace)_"/index.html", 2, *), "MVB.4.MVI", "Dummy.Package.Class.CLS"), itemName) > 0
    set assertion = $$$FormatText(templateAssertion, itemLocation, $case(flag, 1: "KEPT", : "PURGED"))
    do $$$AssertEquals(##class(%File).Exists(itemLocation), flag, assertion)
  }
]]></Implementation>
</Method>

<Method name="T">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
   
  set ^||Port.Project = "port"
  set t = ..%New(##class(Port.UnitTest.Manager).%New())
  
  do ##class(Port.Configuration).SetCustomWorkspace("dummy-project", t.GetTestDirectory("fixtures/dummy-project"))
  
  $$$QuitOnError(t.OnBeforeOneTest())
  $$$QuitOnError(t.TestPurge())
  $$$QuitOnError(t.OnAfterAllTests())
]]></Implementation>
</Method>
</Class>


<Class name="UnitTest.Port.Util">
<Super>Port.UnitTest.TestCase,UnitTest.Port.Helper</Super>
<TimeCreated>64470,32353.462876</TimeCreated>

<Method name="TestResolveItemExtension">
<Implementation><![CDATA[
  set projectName = "mock"
  do ..MockItems(projectName, .entries)
  set $list(entries, $ll(entries) + 1) = "mock.PRJ"
  set expectations = $lb("PKG", "CLS", "CLS", "PKG", "PKG", "INC", "MAC", "DFI", "BAS", "MVB", "MVI", "CSP", "HTML", "HTML", "JS", "HTML", "ONLYEXTENSION", "PRJ")
  for i=1:1:$ll(expectations) {
    set expectation = $lg(expectations, i)
    set entry = $lg(entries, i)
    do $$$AssertEquals(expectation, ##class(Port.Util).ResolveItemExtension(entry), $$$FormatText("resolves %1 -> %2", entry, expectation))
  }
]]></Implementation>
</Method>

<Method name="TestGetItemSourcePathFromWorkspace">
<Implementation><![CDATA[
  
  set projectName = "mock"  
  
  do ##class(Port.Configuration).SetPrimaryWorkspace("/CacheProjects/{NAMESPACE}/{PROJECT}")  
    
  do ..MockItems(projectName, .entries, .expectations)  
  
  for i=1:1:$ll(entries) {
    set entry = $lg(entries, i)
    set expectation = $lg(expectations, i)
    set result = ##class(Port.Util).GetItemSourcePathFromWorkspace(entry, projectName)    
    do $$$AssertEquals(expectation, ##class(Port.Util).GetItemSourcePathFromWorkspace(entry, projectName), $$$FormatText("resolves %1 -> %2", entry, expectation))
  }
]]></Implementation>
</Method>

<Method name="TestExtractType">
<Implementation><![CDATA[
  set projectName = "mock"  
  do ..MockItems(projectName, "", .entries)
  set expectations = $lb("CLS", "CLS", "CLS", "CLS", "CLS", "INC", "MAC", "DFI", "BAS", "MVB", "MVI", "WEB", "WEB", "WEB", "WEB", "WEB", "WEB")
  for i=1:1:$listlength(expectations) {
    set entry = $listget(entries, i)
    set expectation = $listget(expectations, i)
    set result = ##class(Port.Util).ExtractType(entry, ##class(Port.Configuration).GetWorkspace(projectName))
    do $$$AssertEquals(expectation, ##class(Port.Util).ExtractType(entry, ##class(Port.Configuration).GetWorkspace(projectName)), $$$FormatText("extracts %1 -> %2", entry, expectation))
  }
]]></Implementation>
</Method>

<Method name="TestMountIdFromName">
<Implementation><![CDATA[
  set projectName = "mock"
  set macs = $lb("BAS", "INT", "INC", "MVI", "MAC")
  
  do ..MockItems(projectName, .entries)
  
  for i=1:1:$listlength(entries) {
    set entry = $listget(entries, i)
    set entry = $replace(entry, "/", "", 1, 1)
    set expectation = entry
    set extension = ##class(Port.Util).ResolveItemExtension(entry)
    
    if extension = "PKG" {
      // Even though it's not need since ResolveItemExtension always defaults to PKG if no extension is found,
      // We'll still enforce it because the idea is to test a behavior similar to AddItem/RemoveItem, which requires an extension.      
      if entry '[ ".PKG" set entry = entry_".PKG"
      set expectation = $replace(entry, ".PKG", "")_"||PKG"
    } elseif $lf(macs, extension) {
      set expectation = entry_"||MAC"
    } elseif ##class(Port.Util).IsRoutine(entry) {
      set expectation = entry_"||"_extension
    } elseif extension = "CLS" { 
      set expectation = $piece(entry, ".", 1, *-1)_"||"_extension
    }else {
      set expectation = entry_"||CSP"
    }
    set expectation = projectName_"||"_expectation
    do $$$AssertEquals(expectation, ##class(Port.Util).MountIdFromName(entry, projectName), $$$FormatText("mounts id %1 -> %2", entry, expectation))
  }
]]></Implementation>
</Method>

<Method name="TestCSPLogicalToPhysicalPath">
<Implementation><![CDATA[
  #define CSPLogicalToPhysicalPath(%CSPItem, %path) set sc = ##class(Port.Util).CSPLogicalToPhysicalPath(%CSPItem, %path)
  #define Normalize(%path) ##class(%File).NormalizeFilename(%path)
  
  set sc = $$$OK
  set expectedPath = $$$Normalize($System.Util.InstallDirectory()_"csp/"_$$$lcase($namespace)_"/dummyfile.js")
  
  do $$$LogMessage("Creating mock application ...")
  
  set sc = ..CreateMockApplication()  
  
  if $$$ISERR(sc) {
    do $$$LogMessage("Unable to create mock application. Aborting current test ...")
    do $$$LogMessage("Reason: "_$System.Status.GetErrorText(sc))
    do $$$AssertStatusOK(sc, "should have created the mock app.")
    quit
  } else {
    do $$$LogMessage("Mock application created with success.")
  }
  
  $$$CSPLogicalToPhysicalPath("unittest/mockapp/dummyfile.js", .resolvedPath)
  do $$$LogMessage("Resulting physical path is: "_resolvedPath)
  
  do $$$AssertEquals(resolvedPath, expectedPath, "resolves dummyfile.js's physical path.")
  
  set expectedPath = $$$Normalize($System.Util.InstallDirectory()_"csp/"_$$$lcase($namespace)_"/subpath/dummyfile.js")
  
  $$$CSPLogicalToPhysicalPath("unittest/mockapp/subpath/dummyfile.js", .resolvedPath)
  do $$$LogMessage("Resulting physical path is: "_resolvedPath)
  
  do $$$AssertEquals(resolvedPath, expectedPath, "resolves subpath/dummyfile.js's physical path.")
  
  set sc = ..DestroyMockApplication()
  
  if $$$ISERR(sc) {
    do $$$LogMessage("Unable to destroy mock application.")
    do $$$LogMessage("Reason: "_$System.Status.GetErrorText(sc))
    do $$$AssertStatusOK(sc, "destroys the mock app.")
  } else {
    do $$$LogMessage("Mock application destroyed with success.")
  }
  
  $$$CSPLogicalToPhysicalPath("unittest/mockapp/dummyfile.js", .absolutePath)
  do $$$AssertStatusNotOK(sc, "returns a status code indicating that the current namespace doesn't have an application.")
]]></Implementation>
</Method>

<Method name="TestCSPPhysicalToLogicalPath">
<Implementation><![CDATA[
  set input = ##class(%File).NormalizeFilename("/foo/web/bar/dummy.txt")
  set expectedResult = $e($System.CSP.GetDefaultApp($namespace)_"/bar/dummy.txt", 2, *)
  
  set sc = ##class(Port.Util).CSPPhysicalToLogicalPath(input, .logicalPath)
  do $$$AssertStatusOK(sc, "returns the logical path without errors.")
    
  do $$$AssertEquals(logicalPath, expectedResult, "resolves the path to logical.")
  
  set sc = ##class(Port.Util).CSPPhysicalToLogicalPath(input, .logicalPath, "dummyns")  
  do $$$AssertStatusNotOK(sc, "returns an error when called with an invalid namespace.")
]]></Implementation>
</Method>

<Method name="TestIsRoutine">
<Implementation><![CDATA[
  #define IsRoutine(%dummyRoutine) ##class(Port.Util).IsRoutine(%dummyRoutine)
  
  do $$$AssertTrue($$$IsRoutine("dummy.inc"), "expects inc to be a routine.")
  do $$$AssertTrue($$$IsRoutine("dummy.int"), "expects int to be a routine.")
  do $$$AssertTrue($$$IsRoutine("dummy.mac"), "expects mac to be a routine.")
  do $$$AssertTrue($$$IsRoutine("dummy.mvb"), "expects mvb to be a routine.")
  do $$$AssertTrue($$$IsRoutine("dummy.bas"), "expects bas to be a routine.")
  
  do $$$AssertNotTrue($$$IsRoutine("dummy.txt"), "expects txt to not be a routine.")
  do $$$AssertNotTrue($$$IsRoutine("dummy.csp"), "expects csp to not be a routine.")
  do $$$AssertNotTrue($$$IsRoutine("dummy.cls"), "expects cls to not be a routine.")
]]></Implementation>
</Method>

<Method name="TestClassToFile">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  for i="txt","whatever","composed.txt","" {
    set assertionSufix = $select(i="" : "nothing", 1: i)_"."
    do ..AssertTestClassToFile(i, assertionSufix)
  }
]]></Implementation>
</Method>

<Method name="TestFileToClass">
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  
  for i=".txt",".whatever",".composed.txt","" {
    set assertionSufix = $select(i="" : "nothing", 1: i)
    do ..AssertTestFileToClass(i, assertionSufix)
  }
]]></Implementation>
</Method>

<Method name="TestExistsInProject">
<Implementation><![CDATA[
  do $$$AssertEquals(##class(Port.Util).ExistsInProject("port", "Port.Util.CLS"), 1, "true if class exists")
  do $$$AssertEquals(##class(Port.Util).ExistsInProject("port", "%Library.RegisteredObject.CLS"), 0, "false if class does not exist")
  
  do $$$AssertEquals(##class(Port.Util).ExistsInProject("port", "portmd.INC"), 1, "true if include exists")
  do $$$AssertEquals(##class(Port.Util).ExistsInProject("port", "whatever.INC"), 0, "false if include does not exist")
]]></Implementation>
</Method>

<Method name="TestListConflicts">
<Implementation><![CDATA[
     
  do ..CreateDummyProject()
  
  do $$$AssertEquals($lb("dummy-project"), ##class(Port.Util).ListConflicts("port", "Port.SourceControl.AutoInstall.CLS"), "returns a list that contains 'dummy-project'")
  do $$$LogMessage("Removing the added item ...")
  
  do ..RemoveDummyProjectItem()
  
  do $$$AssertEquals("", ##class(Port.Util).ListConflicts("port", "Port.SourceControl.AutoInstall.CLS"), "returns an empty list")
  
  set project = ""
  do ##class(%Studio.Project).Delete("dummy-project")
]]></Implementation>
</Method>

<Method name="TestCreateMissingPath">
<Implementation><![CDATA[
  do $$$AssertStatusOK(##class(Port.Util).CreateMissingPath(..GetTestDirectory("../temp")), "creates a directory")
  do $$$AssertStatusOK(##class(Port.Util).CreateMissingPath(..GetTestDirectory("../temp")), "tries to create the same directory, nothing should happen.")
  
  do $$$AssertStatusNotOK(##class(Port.Util).CreateMissingPath(..GetTestDirectory("../temp/(*347dhdsk::)$¬®¬®#")), "returns an error when the path is invalid.")
  
  do ##class(%File).RemoveDirectory(..GetTestDirectory("../temp"))
]]></Implementation>
</Method>

<Method name="AssertTestClassToFile">
<FormalSpec>extension:%String="",assertionSuffix:%String</FormalSpec>
<Implementation><![CDATA[
  set basePath = "/CacheProjects/MOCKNS/mockproject/cls"
  set input = "MockApp.Package.Test"
  set expected = ##class(%File).NormalizeFilename(basePath_"/MockApp/Package/Test.cls."_extension)
  
  set result = ##class(Port.Util).ClassToFile(basePath, input, extension)
  //do $$$AssertEquals(result, expected, "resolves correctly the class when the extension is "_assertionSuffix_".")
]]></Implementation>
</Method>

<Method name="AssertTestFileToClass">
<FormalSpec>extension:%String="",assertionSuffix:%String</FormalSpec>
<Implementation><![CDATA[
  set input = "/CacheProjects/"_$namespace_"/MockProject/cls/MockApp/Package/Test.cls"_extension
  set expectedOutput = "MockApp.Package.Test"
  set result = ##class(Port.Util).FileToClass(input, $piece(extension, ".", 2))
  return result
  
  do $$$LogMessage(result_" -> "_expectedOutput)
  do $$$AssertEquals(result, expectedOutput, "resolves the source file to Cach√© class name when extension is "_assertionSuffix)
]]></Implementation>
</Method>

<Method name="TestTranslatePath">
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  set windowsPath = "C:\Somewhere\Deep\In\The\Windows\System32\drivers\youcanfindme.sys"
  set unixPath = "/home/cacheusr/file.txt"

  set expected = "/Somewhere/Deep/In/The/Windows/System32/drivers/youcanfindme.sys"
  set translation = ##class(Port.Util).TranslatePath(windowsPath, 3)  
  
  do $$$AssertEquals(expected, translation, "Can translate Windows to Unix path")   
  
  set expected = "C:\home\cacheusr\file.txt"
  set translation = ##class(Port.Util).TranslatePath(unixPath, 2)
  
  do $$$AssertEquals(expected, translation, "Can translate Unix to Windows path")
  
  set erroneousWindowsPath = "C:/oops/not\like\this.txt" 
  set expected = "C:\oops\not\like\this.txt"
  set translation = ##class(Port.Util).TranslatePath(erroneousWindowsPath, 2)
  
  do $$$AssertEquals(expected, translation, "Can fix erroneous Windows paths")
  
  set erroneousUnixPath = "/home/oops\not\like/this.txt"
  set expected = "/home/oops/not/like/this.txt"
  set translation = ##class(Port.Util).TranslatePath(erroneousUnixPath, 3)
  
  do $$$AssertEquals(expected, translation, "Can fix erroneous Unix paths")
]]></Implementation>
</Method>
</Class>


<Project name="port" LastModified="2019-04-05 16:50:51.803399" Target="##class(Port.Util).ExtractType(&quot;C:\CacheProjects\DEV\Frontier\cls\My\Class.cls&quot;, &quot;C:\CacheProjects\DEV\Frontier&quot;)" TargetType="2" HttpServer="http://localhost:57772">
  <Items>
    <ProjectItem name="Port.AutoInstall" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Configuration" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Installer" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Logger" type="CLS"></ProjectItem>
    <ProjectItem name="Port.MAC" type="MAC"></ProjectItem>
    <ProjectItem name="Port.Project.Backup" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Base" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Exporter" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Importer" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.Synchronizer" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Project.XMLExporter" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.ExtendedHooks" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Hooks" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.Log" type="CLS"></ProjectItem>
    <ProjectItem name="Port.SourceControl.LogCleaner" type="CLS"></ProjectItem>
    <ProjectItem name="Port.TestUtils.MockProject" type="CLS"></ProjectItem>
    <ProjectItem name="Port.UnitTest.Manager" type="CLS"></ProjectItem>
    <ProjectItem name="Port.UnitTest.TestCase" type="CLS"></ProjectItem>
    <ProjectItem name="Port.UnitTest.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Util" type="CLS"></ProjectItem>
    <ProjectItem name="Port.Wizard" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Port.Helper" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Port.Logger" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Port.Project.Exporter" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Port.Project.Synchronizer" type="CLS"></ProjectItem>
    <ProjectItem name="UnitTest.Port.Util" type="CLS"></ProjectItem>
    <ProjectItem name="portmd.INC" type="MAC"></ProjectItem>
    <ProjectItem name="portutils.INC" type="MAC"></ProjectItem>
  </Items>
  <BreakPoints>
    <BreakPoint Routine="Port.Util.CLS" Offset="CSPPhysicalToLogicalPath+7"></BreakPoint>
    <BreakPoint Routine="XPort.API.Project.Items.CLS" Offset="PublishItems+26"></BreakPoint>
  </BreakPoints>
</Project>


<Routine name="portmd" type="INC"><![CDATA[
#define PCWGoBackChoice                                 -7999
#define PCWPathNew                                      -7985
#define PCWPathCurrent                                  -7984
#define PCWPathDefault                                  -7983
#define PCWPathOSSchemes                                -7982
#define PCWPathAbsolute                                 -7981
#define PCWPathRelative                                 -7980
#define PCWPlaceholdersInstallDir                       -7974
#define PCWPlaceholdersUsername                         -7973
#define PCWPlaceholdersNamespace                        -7972
#define PCWPlaceholdersProject                          -7971
#define PCWPlaceholdersAnnounce                         -7970
#define PCWExit                                         -7600
#define PWCSetSourceExtensionStatusNow                  -7503
#define PWCSetSourceExtensionPrompt                     -7502
#define PCWSetSourceExtensionDescription                -7501
#define PCWSetSourceExtensionChoice                     -7500
#define PCWSetLogLevelStatusChoice2                     -7420
#define PCWSetLogLevelStatusChoice1                     -7410
#define PCWSetLogLevelStatusPrompt                      -7404
#define PCWSetLogLevelStatusNow                         -7403
#define PCWSetLogLevelStatusCurrent                     -7402
#define PCWSetLogLevelDescription                       -7401
#define PCWSetLogLevelChoice                            -7400
#define PCWToggleAutoExportChoice2                      -7320
#define PCWToggleAutoExportChoice1                      -7310
#define PCWToggleAutoExportChoice1StatusNow             -7303
#define PCWToggleAutoExportChoice1StatusCurrent         -7302
#define PCWToggleAutoExportDescription                  -7301
#define PCWToggleAutoExportChoice                       -7300
#define PCWManageChangeTestSettingsChoice3StatusNow     -7232
#define PCWManageChangeTestSettingsChoice3Description   -7231
#define PCWManageChangeTestSettingsChoice3              -7230
#define PCWManageChangeTestSettingsChoice2StatusNow     -7225
#define PCWManageChangeTestSettingsChoice2Prompt        -7224
#define PCWManageChangeTestSettingsChoice2Description3  -7223
#define PCWManageChangeTestSettingsChoice2Description2  -7222
#define PCWManageChangeTestSettingsChoice2Description   -7221
#define PCWManageChangeTestSettingsChoice2              -7220
#define PCWManageChangeTestSettingsChoice1StatusCurrent -7214
#define PCWManageChangeTestSettingsChoice1Choice2       -7213
#define PCWManageChangeTestSettingsChoice1Choice1       -7212
#define PCWManageChangeTestSettingsChoice1Description   -7211
#define PCWManageChangeTestSettingsChoice1              -7210
#define PCWManageChangeTestSettingsDescription          -7201
#define PCWManageChangeTestSettingsChoice               -7200
#define PCWManageWorkspaceChoice2StatusNow              -7128
#define PCWManageWorkspaceChoice2Prompt2                -7127
#define PCWManageWorkspaceChoice2CurrentWorskpaceWarn   -7126
#define PCWManageWorkspaceChoice2StatusCurrent          -7125
#define PCWManageWorkspaceChoice2Warning                -7124
#define PCWManageWorkspaceChoice2Prompt                 -7123
#define PCWManageWorkspaceChoice2Description2           -7122
#define PCWManageWorkspaceChoice2Description            -7121
#define PCWManageWorkspaceChoice2                       -7120
#define PCWManageWorkspaceChoice1StatusNow              -7113
#define PCWManageWorkspaceChoice1StatusCurrent          -7112
#define PCWManageWorkspaceChoice1Description            -7111
#define PCWManageWorkspaceChoice1                       -7110
#define PCWManageWorkspaceDescription                   -7101
#define PCWManageWorkspaceChoice                        -7100
#define PCWBye                                          -7007
#define PCWToggleDisabled                               -7006
#define PCWToggleEnabled                                -7005
#define PCWAborted                                      -7004
#define PCWChoicePrompt                                 -7003
#define PCWChoiceQuestion                               -7002
#define PCWInvalidChoice                                -7001
#define PCWWelcome                                      -7000
#define CMLRunActiveTest                                -6002
#define CMLImportActive                                 -6001
#define CMLExportActive                                 -6000
#define FailedWhileRunningExtendedHook                  -118
#define CannotSaveConflictingItems                      -117
#define CouldNotDetermineWorkspace                      -116
#define LogLevelIsOutOfRange                            -115
#define ErrorsWhileImportingType                        -114
#define ExportingProjectNotFound                        -113
#define NoTestSuitesWereFound                           -112
#define PortIsNotInstalled                              -111
#define UnableToDescribeItem                            -110
#define UnableToRemoveDirectory                         -109
#define SupressedAttemptToExportFromOutside             -108
#define AmbiguousPartialToWorkspace                     -107
#define ErrorsWhileImporting                            -106
#define UnableToExportInvalidItem                       -105
#define UnableToCopySource                              -104
#define CannotUseRelativePath                           -103
#define CannotCreateDirectory                           -102
#define NamespaceDoesntHaveAppWithPath                  -101
#define InvalidPhysicalPath                             -100
#define HookReturnedError                               -1102
#define HookReturnedOK                                  -1101
#define RunningCustomHook                               -1100
#define ConflictingItemDetected2                        -1001
#define ConflictingItemDetected                         -1000
#define ExportingTestClassToXML                         -902
#define XMLExportedTo                                   -901
#define ExportingXML                                    -900
#define FileGroupType                                   -813
#define CLSGroupType                                    -812
#define DFIGroupType                                    -811
#define MVIGroupType                                    -810
#define MVBGroupType                                    -809
#define BASGroupType                                    -808
#define INTGroupType                                    -807
#define INCGroupType                                    -806
#define MACGroupType                                    -805
#define DirectoryType                                   -804
#define FileType                                        -803
#define RoutineType                                     -802
#define ProjectType                                     -801
#define ClassType                                       -800
#define CannotUseDefault2                               -701
#define CannotUseDefault                                -700
#define ProjectSaved                                    -614
#define FatalFailedToRestoreBackup                      -613
#define FatalApplyingBackup                             -612
#define FatalRollingBackTransaction                     -611
#define FatalProjectIntegrityRiskWarning                -610
#define FatalRollbackAlert                              -609
#define FatalErrorAlert                                 -608
#define NewProject                                      -607
#define NoPendingItemsToImport                          -606
#define TotalItemsToImport                              -605
#define EnqueueingItems                                 -604
#define ImportingProject                                -603
#define NothingToImport                                 -602
#define EnqueingType                                    -601
#define ImportingType                                   -600
#define OvewriteWithExtension                           -504
#define KeepCacheExtension                              -503
#define AllDone                                         -502
#define Failed                                          -501
#define Done                                            -500
#define TotalExtraneousItemsRemoved                     -406
#define RemovingDirectory                               -405
#define RemovingFile                                    -404
#define NoExtraneousItems                               -403
#define TotalExtraneousItems                            -402
#define CheckingExtraneousItems                         -401
#define SynchronizingProject                            -400
#define NewWorkspaceDetected                            -304
#define ExportingType                                   -303
#define SourceExportedToPath                            -302
#define ExportingProject                                -301
#define NoItemsToExport                                 -300
#define RemovingBackupMirror                            -203
#define BackupMirror                                    -202
#define BackupAlert                                     -201
#define BackupStart                                     -200
#define MLForceImport                                   -5010
#define MLForceExport                                   -5009
#define MLImport                                        -5008
#define MLRunTests                                      -5007
#define MLScanAndFix                                    -5006
#define MLRemoveRoutines                                -5005
#define MLRemoveFiles                                   -5004
#define MLRemoveClasses                                 -5003
#define MLExportTests                                   -5002
#define MLExportToXML                                   -5001
#define MLExport                                        -5000
]]></Routine>


<Routine name="portutils" type="INC"><![CDATA[
#include %occStatus
#include %occMessages
#include %occErrors

#include portmd

#define ImportTypes                      $listbuild("INC", "INT", "CLS", "MAC", "MVI", "MVB", "BAS", "DFI", "CSR", "CSP")
#define ImportTypeDescriptions           $listbuild("include files", "intermediate routines", "classes", "macro routines",  "MV Intermediate routines", "MV Basic routines", "Basic routines", "DFI XML", "CSP Rules", "files")
#define RoutineExtensions                $listbuild(".MAC", ".INT", ".INC", ".MVB", ".MVI", ".BAS", ".DFI")
#define RoutinesGroups                   "MAC,INT,INC,MVB,MVI,BAS,DFI"
#define IsRoutine(%type)                 ($$$RoutinesGroups[%type)
#define GetTypeDescription(%type)        $select($$$IsRoutine(%type)=1:$$$RoutineType,(%type = "CLS"):$$$ClassType,(%type = "PRJ"):$$$ProjectType,1:$$$FileType)
#define GetGroupTypeDescription(%type)   $case(%type,"MAC":$$$MACGroupType,"INC":$$$INCGroupType,"INT":$$$INTGroupType,"BAS":$$$BASGroupType,"MVB":$$$MVBGroupType,"MVI":$$$MVIGroupType,"DFI":$$$DFIGroupType,"CLS":$$$CLSGroupType,:$$$FileGroupType)
#def1arg PERROR(%errorArgs)              $$$ERROR($$$GeneralError, $$$FormatMsg("Port Errors", %errorArgs))
#def1arg FormatWizardMsg(%args)          $$$FormatMsg("Port Configuration Wizard", %args)
#define RemoveClassExtension(%iname)     $select($piece(%iname, ".", $$$ucase(%iname), *) [ "CLS" :  $piece(%iname, ".", 1, *-1), 1: %iname)
#define Slash(%path)                     $select($$$IsRemoteAware : $select(%path [ "\" : "\", 1: "/"), 1: $$$OSSlash)
#define OSSlash                          $select($$$isWINDOWS : "\", 1: "/")
#define OSFromSlash(%path)               $select(%path [ "\" : 2, 1: 3)
#define PathSlash(%path)                 $select(%path [ "\" : "\", 1: "/")
#define NFN(%path)                       $select($$$IsRemoteAware : ##class(Port.Util).TranslatePath(%path, $$$OSFromSlash(%path)), 1: ##class(Port.Util).TranslatePath(%path))
#define IsRemoteAware                    $get(^||Port.Internals.Configuration("remote")) = 1

]]></Routine>
</Export>
